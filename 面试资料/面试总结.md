# 自我介绍

我叫谭方川，是一名计算机专业的本科生，因为大学教授的东西有些不符合企业招聘要求，所以我在招聘网站网查找企业需要的技能，大学期间自学了这些技术，例如Spring、Spring Boot、MyBatis，以更好的满足企业招聘需求。我在大学期间参加过算法竞赛并且也获得了国家级的奖项。我自己做也过一些项目，有相关的开发经验，能够快速学习一个技能并应用到项目中。生活中我是一个比较积极乐观的人，喜欢各种运动，在校期间也积极参加校各种活动。最后，很希望能够加入贵公司，谢谢。



# 项目

## 校园师生服务

> `Spring Security` 身份认证流程

1、用户名和密码被过滤器获取到，封装成 `Authentication`，通常情况下是 `UsernamePasswordAuthenticationToken` 这个实现类。

2、`AuthenticationManager` 身份管理器（一般是 `ProviderManager`）负责验证这个 `Authentication` 

3、认证成功后，`AuthenticationManager` 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）`Authentication` 实例。

4、`SecurityContextHolder` 安全上下文容器将第 3 步填充了信息的 `Authentication` 保存到 `SecurityContext` 上下文中（实际上是一个 `ThreadLocal`）

> `Spring Security` 授权流程

通过各种过滤器、拦截器实现



## 分布式电商

问题：不同微服务之间的登录信息共享

**`Session` 工作流程**：

1、浏览器向服务器发送请求后，服务器会生成一个 `Session`，并将 `Session` 的 ID（`JSESSIONID`） 以 `Cookie` 方式返回，浏览器会保存这个 `Cookie`，以后每次请求都会带着这个 `Cookie`。

2、浏览器再次请求服务器时，服务器会根据 `JSessionID` 的值来获取对应的 `Session`，从而获取保存在 `Session` 中的数据

3、浏览器中保存的 `Cookie` 都是有作用域的，作用域的范围就是域名的范围，例如 `wwww.a.com` 无法访问 `www.b.com` 中的 `Cookie`，在该域名下服务器也就无法获取 `Session`，也就无法获取 `Session` 中的数据，此时服务器就会创建一个新的 `Session`，并返回 `Session` 的 ID。

**不同域名的 `Session` 共享解决方案**：

1）`hash` 一致性：通过计算 `hash` 将某个 `IP` 下的请求都发送到同一个服务器

**问题**：

* 如果部分服务器宕机就会有一部分用户需要重新登录
* 重启之后 `hash` 值会变

2）**同一存储问题**：将所有的 `Session` 都存储到同一台服务器

**问题**：

* 多了一次网络交互



**`Session` 的子域共享问题**：例如 `mall.tfc.com` 和 `abc.tfc.com` 无法共享 `Session`，但 `.tfc.com` 域名下的都是可以共享的，可以用 `Spring Session` 来解决这个问题，在存储的时候就设置作用域。

```java
@Configuration
public class SessionConfig implements BeanClassLoaderAware {
    
    @Bean
	public CookieSerializer cookieSerializer() {
		DefaultCookieSerializer serializer = new DefaultCookieSerializer();
		serializer.setCookieName("JSESSIONID"); 
		serializer.setDomainName("tfc.com");     // 自定义 Session 作用域
		return serializer;
	}
    
    // 自定义序列化器（JSON 格式）
	@Bean
	public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
		return new GenericJackson2JsonRedisSerializer(objectMapper());
	}
}
```

> `Spring Session` 原理

利用 `Filter` 过滤器将原生的 `Request`、`Response` 包装成自定义的返回



# 设计模式





# 浏览器输入 URL 发生的事情

1、浏览器查找域名的 `IP` 地址，查找过程：浏览器缓存、路由缓存、`DNS` 缓存、`DNS` 服务器

2、找到 `IP` 就找到了服务器，向服务器发送一个 `HTTP` 请求，`Cookie` 会一起发送给浏览器

3、服务器处理请求返回 `HTML` 网页数据，浏览器显示数据

> 这个过程中用到的协议

`TCP`：浏览器与服务器之间是 `TCP` 协议

`IP`：发送数据时，需要知道下一个节点 `IP`，需要 `IP` 协议

`OPSF`：数据包在路由器之间传输使用该协议

`ARP`：路由器在与服务器通信时，需要将 `IP` 转换为 `MAC` 地址时使用该协议

`HTTP`：在连接建立以后，使用 `HTTP` 协议访问网页



# TCP 如何保证数据传输的可靠性

1、首先将数据分割为 `TCP` 认为最合适的大小块，也叫数据包，每个数据包都有一个编号，接收端按顺序接收

2、**校验和**：数据包中有校验字段，如果接收端根据此校验数据计算出错，则丢弃该数据包，并且接收端会丢弃重复的数据

3、**流量控制**：发送方、接收方都有一个固定大小的缓冲区，缓冲区快慢的时候接收端会提示发送端降低发送速率，方式丢包，流量控制使用**滑动窗口** 

4、**拥塞控制**：当网络拥堵时减少数据的发送

5、`ARQ` 协议：发完一个分组就等待对方确认，收到确认后再发送下一个分组

6、**超时重传**：当发送一个数据后，会启动一个定时器，如果规定等待时间内没有收到确认消息，则重新发送该数据



# 有了字节流，为什么还要字符流？

字符流是 `Java` 虚拟机转换字节得到的，这个过程非常耗时，并且如果不知道编码的话很容易出现乱码问题，所以干脆直接提供一个操纵字符的接口，方便对字符的操作。但是音频、图片等媒体文件用字节流比较好。





# Spring Boot 自动装配原理

1、点击 `@SpringBootApplication` 会发现该注解上标了一个 `@EnableAutoConfiguration`，该注解是自动配置核心内容

2、`@EnableAutoConfiguration` 导入了一个 `AutoConfigurationImportSelector` 类，该类实了 `ImportSelector` 接口，重写了 `selectImports()` 方法

3、`selectImports()` 方法中调用了 `getAutoConfigurationEntry()` 方法，该方法负责加载自动配置类，这个方法会加载所有 `Jar` 包下 `META-INF` 中的 `spring.factories` 配置的类，过滤掉不需要的类

**可以自己 `Debug` 看一看** 



## 自己实现一个 Starter

1、新建一个项目：`thread-spring-boot-starter` 

2、新建一个配置类：`ThreadAutoConfiguration`，随便加一点东西

```java
@Configuration
public class ThreadAutoconfiguration {

    @Bean
    @ConditionalOnClass(ThreadPoolExecutor.class)
    public ThreadPoolExecutor executor() {
        return new ThreadPoolExecutor(5, 10, 10, TimeUnit.MINUTES, new ArrayBlockingQueue<>(100));
    }
}
```

3、在`thread-spring-boot-starter`工程的 `resources ` 包下创建 `META-INF/spring.factories` 文件

4、最后新建工程引入 `thread-spring-boot-starter` 测试：

```java
@Autowired
ThreadPoolExecutor executor;

@Test
void contextLoads() {
    System.out.println(executor.getCorePoolSize());
}
```





# 稳赢云-上海

## 1、MySQL隔离级别，默认隔离级别

MySQL的事务隔离级别一共有四个，分别是：读未提交、读已提交、可重复读（默认）、可串行化。



## 2、MySQL锁机制

**MyISAM 和 InnoDB 存储引擎使用的锁**：

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁

**只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁** 

SQL的更新（update）或者删除（delete）语句中未使用到索引，导致在InnoDB在对数据进行相应操作的时候必须把整个表锁起来进行检索（表锁）。而如果使用了索引的话，InnoDB 只会通过索引条件检索数据，而只锁住索引对应的行（行锁）。

> 锁算法

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：锁定一个范围，包含记录本身



## 3、实现线程安全的方法有哪几种

* 使用线程安全的类，JUC包下的类
* 使用 synchronize 修饰
* lock接口
* volatile+CAS【单纯的volatile是轻量级的同步机制保证可见性但是不具备原子性所以要配合CAS来实现线程安全】
* atomic 原子类



## 4、Spring 中实现事务的方式

> **编程式事务管理** 

通过 `TransactionTemplate`手动管理事务，实际应用中很少使用

```java
@Autowired
private TransactionTemplate transactionTemplate;

public void testTransaction() {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
            try {
                // ....  业务代码
            } catch (Exception e) {
                //回滚
                transactionStatus.setRollbackOnly();
            }
        }
    });
}
```

通过`TransactionManager`手动管理事务

```java
@Autowired
private PlatformTransactionManager transactionManager;  // 使用之前需要往容器中注入一个该接口的实现类

public void testTransaction() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
        // ....  业务代码
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
    }
}
```

`PlatformTransactionManager`：该接口中定义了事务的基本规则，具体实现由各个厂家实现

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}
```

`getTransaction()` 用来获取一个事务，需要传入一个 `TransactionDefinition`，该参数包含了一些事务的基本属性：传播行为、隔离级别、回滚规则、是否只读、事务超时等属性

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;

    default int getPropagationBehavior() {
        return 0;
    }

    default int getIsolationLevel() {
        return -1;
    }

    default int getTimeout() {
        return -1;
    }

    default boolean isReadOnly() {
        return false;
    }

    @Nullable
    default String getName() {
        return null;
    }

    static TransactionDefinition withDefaults() {
        return StaticTransactionDefinition.INSTANCE;
    }
}
```

`PlatformTransactionManager.getTransaction(…)`方法返回一个 `TransactionStatus` 对象，由该对象可以获取一些事务的设置情况

```java
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
```



> 声明式事务管理：**@Transaction** 注解

**方法** ：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效**。

**类** ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

**接口** ：不推荐在接口上使用

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    @AliasFor("transactionManager")
    String value() default "";
    @AliasFor("value")
    String transactionManager() default "";
    String[] label() default {};
    Propagation propagation() default Propagation.REQUIRED;   // 传播行为
    Isolation isolation() default Isolation.DEFAULT;          // 隔离级别
    int timeout() default -1;                                 // 超时时间
    String timeoutString() default "";
    boolean readOnly() default false;                         // 是否只读
    Class<? extends Throwable>[] rollbackFor() default {};    // 回滚规则
    String[] rollbackForClassName() default {};
    Class<? extends Throwable>[] noRollbackFor() default {};
    String[] noRollbackForClassName() default {};
}
```

`propagation`传播行为：在`TransactionDefinition`定义中包括了表示传播行为的常量，不过如此，为了方便使用，Spring 会相应地定义了一个枚举类`Propagation` 

```java
public enum Propagation {
    REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3),NOT_SUPPORTED(4), NEVER(5), NESTED(6);

    private final int value;

    private Propagation(int value) {
        this.value = value;
    }
    public int value() {
        return this.value;
    }
}
```

1）`REQUIRED`：使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。**如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务**。

举个例子：如果我们上面的`aMethod()`和`bMethod()`使用的都是`PROPAGATION_REQUIRED`传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}
Class B {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void bMethod {
       //do something
    }
}
```

2）`REQUIRES_NEW`：**创建一个新的事务，如果当前存在事务，则把当前事务挂起**。也就是说不管外部方法是否开启事务，`REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。

举个例子：如果我们上面的`bMethod()`使用`REQUIRES_NEW`事务传播行为修饰，`aMethod`还是用`REQUIRED`修饰的话。如果`aMethod()`发生异常回滚，`bMethod()`不会跟着回滚，因为 `bMethod()`开启了独立的事务。但是，如果 `bMethod()`抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,`aMethod()`同样也会回滚，因为这个异常被 `aMethod()`的事务管理机制检测到了。 

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}
Class B {
    @Transactional(propagation=propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
```

3）`NESTED`：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则该取值等价于`REQUIRED`。也就是说：

1. 在外部方法未开启事务的情况下`NESTED`和`REQUIRED`作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。

2. 如果外部方法开启事务的话，`NESTED`修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。

这里还是简单举个例子：如果 `aMethod()` 回滚的话，`bMethod()`和`bMethod2()`都要回滚，而`bMethod()`回滚的话，并不会造成 `aMethod()` 和`bMethod()2`回滚。

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
        b.bMethod2();
    }
}
Class B {
    @Transactional(propagation=propagation.PROPAGATION_NESTED)
    public void bMethod {
       //do something
    }
    @Transactional(propagation=propagation.PROPAGATION_NESTED)
    public void bMethod2 {
       //do something
    }
}
```

4）`MANDATORY`：**如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常**（mandatory：强制性），这个使用的很少，就不举例子来说了。

5）**若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少**。

* `SUPPORTS`：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。

* `NOT_SUPPORTED`：以非事务方式运行，如果当前存在事务，则把当前事务挂起。

* `NEVER`：以非事务方式运行，如果当前存在事务，则抛出异常。



`isolation`事务隔离级别，`TransactionDefinition` 接口中定义了五个表示隔离级别的常量：

```java
public interface TransactionDefinition {
    ......
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    ......
}
```

和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation` 

```java
public enum Isolation {
    DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);

    private final int value;

    private Isolation(int value) {
        this.value = value;
    }
    public int value() {
        return this.value;
    }
}
```

下面我依次对每一种事务隔离级别进行介绍：

- `DEFAULT`：使用后端数据库默认的隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别，Oracle 默认采用的 `READ_COMMITTED` 隔离级别。
- `READ_UNCOMMITTED`：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- `READ_COMMITTED`：允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- `REPEATABLE_READ`：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- `SERIALIZABLE`：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



`timeout`事务超时：一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 `TransactionDefinition` 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1，永不超时。



`readOnly`事务只读：对于只有读取数据查询的事务，可以指定事务类型为 **readonly**，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。

很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？

> MySQL 默认对每一个新建立的连接都启用了`autocommit`模式。在该模式下，每一个发送到 MySQL 服务器的`sql`语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。 

但是，如果你给方法加上了`Transactional`注解的话，这个方法执行的**所有`sql`会被放在一个事务中**。如果声明了只读事务的话，数据库就会去优化它的执行。如果不加`Transactional`，每条`sql`会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。

* 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；

* 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。



`rollbackFor` 事务回滚规则：这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（**RuntimeException** 的子类）时才会回滚，**Error** 也会导致事务回滚，但是，在遇到检查型（**Checked**）异常时不会回滚。

如果你想要回滚你定义的特定的异常类型的话，可以这样：

```java
@Transactional(rollbackFor = MyException.class)
```



## 5、`violation`的特点

由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，**因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存**。

**高速缓存**：将主存中的数据复制一份放到CPU高速缓存中，CPU操作高速缓存速度远比操作主存快，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中

这对于单线程来说没有问题，但对于多线程来说就有点问题，例如有线程 A 和线程 B，**两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程 A 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。最终结果 i 的值是 1，而不是 2**。这就是著名的**缓存一致性**问题。通常称这种被多个线程访问的变量为**共享变量**。

用 `volition` 修饰的关键字每次读取都从主存中读取，没有复制一份到高速缓存中



## 6、用 `final` 修饰的特点

- `final` 类不能被继承，没有子类，final类中的方法默认是final的。 
- `final` 方法不能被子类的方法覆盖，但可以被继承。 
- `final` 成员变量表示常量，只能被赋值一次，赋值后值不再改变。 
- `final` 不能用于修饰构造方法。 



## 7、`MySQL` 事务的四大特性

**原子性（Atomicity）**：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。

**一致性（Consistency）**：官网上事务一致性的概念是——事务必须使数据库从一个一致性状态变换到另外一个一致性状态。例如转账前后两人的总金额是不变的

**隔离性（Isolation）**：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

**持久性（Durability）**：一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。



## 8、死锁产生原因以及解决办法

**死锁产生原因**：线程 A 持有线程 B 所需资源，线程 B 持有线程 A 所需资源，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

```java
public class Main {

    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

**如何预防死锁？** 破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件** ：一次性申请所有的资源。
2. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件** ：靠按序申请资源来预防。**按某一顺序申请资源，释放资源则反序释放**。破坏循环等待条件。

**如何避免死锁？**避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

**安全状态**：指的是系统能够按照某种进程推进顺序（P1、P2、P3.....Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。

我们对线程 2 的代码修改成下面这样就不会产生死锁了。

```java
new Thread(() -> {
    synchronized (resource1) {
        System.out.println(Thread.currentThread() + "get resource1");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread() + "waiting get resource2");
        synchronized (resource2) {
            System.out.println(Thread.currentThread() + "get resource2");
        }
    }
}, "线程 2").start();
```

我们分析一下上面的代码为什么避免了死锁的发生?

线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。



## 9、`ThreadLocal` 作用，会产生什么问题

**作用**：让同一个线程在任何地方都能拿到数据

```java
public class Main implements Runnable {

    // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[] args) throws InterruptedException {
        Main obj = new Main();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(obj, "" + i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("Start: Thread Name = " + Thread.currentThread().getName() + " default Formatter = " + formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("End: Thread Name = " + Thread.currentThread().getName() + " formatter = " + formatter.get().toPattern());
    }
}
```

从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样

**ThreadLocal 原理**：

```java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```

从上面`Thread`类 源代码可以看出`Thread` 类中有一个 `threadLocals` 和 一个 `inheritableThreadLocals` 变量，它们都是 `ThreadLocalMap` 类型的变量。

我们可以把 `ThreadLocalMap` 理解为`ThreadLocal` 类实现的定制化的 `HashMap`。默认情况下这两个变量都是 null，只有当前线程调用 `ThreadLocal` 类的 `set`或`get`方法时才创建它们，实际上调用这两个方法的时候，我们调用的是`ThreadLocalMap`类对应的 `get()`、`set()`方法。 

`ThreadLocal`类的`set()`方法：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。** `ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对**。



**ThreadLocal 内存泄露问题**：

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的**弱引用**，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。

这样一来，`ThreadLocalMap` 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。

`ThreadLocalMap` 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法。



## 10、进程、线程间通信方式

**进程间的常见的通信方式**：

1）**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

2）**有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3）**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

4）**消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点**。

5）**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6）**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

7）**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

**线程间通信的同步方式**：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

* **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

* **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

* **事件(Event)**：Wait/Notify，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。





# 大润发-武汉

## 1、乐观锁、悲观锁

> **乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题**。

1）**乐观锁**：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。

`CAS` **比较并交换**：将预期值 **A** 与内存中的值 **B** 进行比较，如果两者相等，则进行业务逻辑处理，如果不相等，则将 A 更新为当前 B 的值，不断重复操作，直到业务逻辑处理完成。

**版本号机制**：基本思路是在数据中增加一个字段 **version**，表示该数据的版本号，每当数据被修改，版本号加 1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。

2）**悲观锁**：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住（`Synchronize`），直到操作完成后才会释放锁，上锁期间其他人不能修改数据。

> 竞争激烈程度

1）当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。

2）当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源



**乐观锁的缺点**：

假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：

(1) 线程 1 读取内存中数据为 A；

(2) 线程 2 将该数据修改为 B；

(3) 线程 2 将该数据修改为 A；

(4) 线程 1 对数据进行 CAS 操作

**在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题**。

在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：**一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化**。

对于 ABA 问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都 +1；在进行 CAS 操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS 才能执行成功。Java 中的 AtomicStampedReference 类便是使用版本号来解决 ABA 问题的。



## 2、防止表单重复提交

1）**通过 JavaScript 禁用提交按钮（不推荐）**：通过 js 代码，当用户点击提交按钮后，屏蔽提交按钮使用户无法点击提交按钮或点击无效，从而实现防止表单重复提交。**js 代码很容易被绕过，比如用户通过刷新页面方式，或使用 postman 等工具绕过前段页面仍能重复提交表单。因此不推荐此方法**。

2）**给数据库增加唯一键约束（简单粗暴）**：在数据库建表的时候在 ID 字段添加主键约束，用户名、邮箱、电话等字段加唯一性约束，确保数据库只可以添加一条数据。

3）**利用Session防止表单重复提交（推荐）**：服务器返回表单页面时，会先生成一个 token 保存于 session，并把该 token 传给表单页面。当表单提交时会带上 token，服务器拦截器 Interceptor 会拦截该请求，拦截器判断 session 保存的 token 和表单提交token 是否一致，若不一致或 session 的 token 为空或表单未携带 token 则不通过。

首次提交表单时 session 的 token 与表单携带的 token 一致走正常流程，然后拦截器内会删除 session 保存的 token 。当再次提交表单时由于 session 的 token 为空则不通过。从而实现了防止表单重复提交。

4）**使用Post/Redirect/Get模式**：在提交后执行页面重定向，这就是所谓的[Post-Redirect-Get (PRG)]()模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。



## 3、Spring处理请求流程

**流程说明（重要）**：

1）客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。

2）`DispatcherServlet` 根据请求信息调用 `HandlerMapping`，根据 `URL` 解析并生成对应的 `Handler` 处理器返回。

3）解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理，如：参数封装，数据格式转换，数据验证等操作

4）`HandlerAdapter` 会根据 `Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。

5）处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。

6）`ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。

7）`DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。

8）把 `View` 返回给请求者（浏览器）



## 4、缓存雪崩怎么解决

**缓存雪崩**：某一时刻有大面积的缓存失效，也就是数据的过期时间到了，Redis 将之删除，导致大量请求直接访问数据库

**解决办法**：

> **1）设置不同的过期时间** 

不要将大量数据设置同一个过期时间

> 2）**布隆过滤器** 

一种数据结构，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是 0，就是 1，但是初始默认值都是0。

**添加数据**：当要向布隆过滤器中添加一个元素 key 时，我们通过多个hash 函数，算出一个值 k，然后第 k 个特方格置为 1。**比如，hash(key) = 1，那么在第 2 个比特将 0 变为 1，hash(key) = 7，那么将第 8 个比特置为 1，依次类推**。

**判断数据是否存在**：对数据计算 hash 值，判断对应的比特位上是否为 1，但多个数据的 hash 值可能相同，所以如果计算结果对应位置上为 1，数据也不一定存在，但如果为 0，则肯定不存在。

**优点**：二进制组成的数组，占用内存极少，并且插入和查询速度都足够快

**缺点**：随着数据的增加，误判率会增加，无法判断数据一定存在；另外还有一个重要缺点，无法删除数据



## 5、线程池



## 6、多线程创建方式

1）继承 **Thread** 类，重写 **run** 方法

2）实现 **Runnable** 接口

3）实现 **Callable** 接口，可以有返回值



## 7、拦截器、过滤器

> 过滤器（**Filter**）

过滤器的配置比较简单，直接实现`Filter` 接口即可，也可以通过`@WebFilter`注解实现对特定`URL`拦截，看到`Filter` 接口中定义了三个方法。

- `init()` ：该方法在容器启动初始化过滤器时被调用，它在 `Filter` 的整个生命周期只会被调用一次。**注意：这个方法必须执行成功，否则过滤器会不起作用**。
- `doFilter()` ：容器中的每一次请求都会调用该方法， `FilterChain` 用来调用下一个过滤器 `Filter`。
- `destroy()`： 当容器销毁过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 `Filter` 的整个生命周期也只会被调用一次



```java
@Component
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("Filter 前置");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("Filter 处理中");
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {
        System.out.println("Filter 后置");
    }
}
```

> 拦截器（**Interceptor**）

拦截器是**链式调用**，一个应用中可以同时存在多个拦截器`Interceptor`， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。

首先编写一个简单的拦截器处理类，请求的拦截是通过`HandlerInterceptor` 来实现，看到`HandlerInterceptor` 接口中也定义了三个方法。

- `preHandle()` ：这个方法将在请求处理之前进行调用。**注意：如果该方法的返回值为`false` ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行**。
- `postHandle()`：只有在 `preHandle()` 方法返回值为`true` 时才会执行。会在**Controller** 中的方法调用之后，**DispatcherServlet** 返回渲染视图之前被调用。 **有意思的是**：`postHandle()` 方法被调用的顺序跟 `preHandle()` 是相反的，先声明的拦截器 `preHandle()` 方法先执行，而`postHandle()`方法反而会后执行。
- `afterCompletion()`：只有在 `preHandle()` 方法返回值为`true` 时才会执行。在整个请求结束之后， **DispatcherServlet** 渲染了对应的视图之后执行。

```java
@Component
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        System.out.println("Interceptor 前置");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

        System.out.println("Interceptor 处理中");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

        System.out.println("Interceptor 后置");
    }
}
```

将自定义好的拦截器处理类进行注册，并通过`addPathPatterns`、`excludePathPatterns`等属性设置需要拦截或需要排除的 `URL`。

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
    }
}
```

> 过滤器与拦截器的不同

1）**实现原理不一样**：过滤器和拦截器底层实现方式大不相同，过滤器是基于函数回调的，拦截器则是基于 Java 的反射机制（动态代理）实现的

在我们自定义的过滤器中都会实现一个 `doFilter()`方法，这个方法有一个`FilterChain` 参数，而实际上它是一个回调接口。`ApplicationFilterChain`是它的实现类， 这个实现类内部也有一个 `doFilter()` 方法就是回调方法。

```java
public interface FilterChain {
    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;
}
```

`ApplicationFilterChain`里面能拿到我们自定义的`xxxFilter`类，在其内部回调方法`doFilter()`里调用各个自定义`xxxFilter`过滤器，并执行 `doFilter()` 方法。

```java
public final class ApplicationFilterChain implements FilterChain {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response) {
            ...//省略
            internalDoFilter(request,response);
    }
 
    private void internalDoFilter(ServletRequest request, ServletResponse response){
    if (pos < n) {
            //获取第pos个filter    
            ApplicationFilterConfig filterConfig = filters[pos++];        
            Filter filter = filterConfig.getFilter();
            ...
            filter.doFilter(request, response, this);
        }
    }
}
```

而每个`xxxFilter` 会先执行自身的 `doFilter()` 过滤逻辑，最后在执行结束前会执行`filterChain.doFilter()`，也就是回调`ApplicationFilterChain`的`doFilter()` 方法，**以此循环执行实现函数回调**。

2）**使用范围不同**：

* 我们看到过滤器实现的是 `javax.servlet.Filter` 接口，而这个接口是在`Servlet`规范中定义的，也就是说过滤器`Filter` 的使用要依赖于`Tomcat`等容器，导致它只能在`web`程序中使用。

* 而拦截器它是一个`Spring`组件，并由`Spring`容器管理，并不依赖`Tomcat`等容器，是可以单独使用的。不仅能应用在`web`程序中，也可以用于`Application`、`Swing`等程序中。

3）**触发时机不同**：

![image-20220211213059498](https://cdn.jsdelivr.net/gh/tfcCode/image/img/202202112130780.png)

过滤器`Filter`是在请求进入容器后，但在进入`servlet`之前进行预处理，请求结束是在`servlet`处理完以后。

拦截器 `Interceptor` 是在请求进入`servlet`后，在进入`Controller`之前进行预处理的，`Controller` 中渲染了对应的视图之后请求结束。

4）**拦截的请求范围不同**：

过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对`Controller`中请求或访问`static`目录下的资源请求起作用。

5）**注入Bean情况不同**：

在过滤器中注入 **Service** 不会有什么问题，但是在拦截器中注入`service`，发起请求测试一下 ，竟然TM的报错了，`debug`跟一下发现注入的`service`怎么是`Null`啊？**这是因为加载顺序导致的问题，拦截器加载的时间点在`springcontext`之前，而`Bean`又是由`spring`进行管理**。

解决方案也很简单，我们在注册拦截器之前，先将`Interceptor` 手动进行注入。**注意**：在`registry.addInterceptor()`注册的是`getMyInterceptor()` 实例。

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Bean
    public MyInterceptor getMyInterceptor(){
        System.out.println("注入了MyInterceptor");
        return new MyInterceptor();
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 这里注册方式是调用方法，不是直接 new 对象
        registry.addInterceptor(getMyInterceptor()).addPathPatterns("/**");
    }
}
```

6）**控制执行顺序不同**：

实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，不过，有时我们希望某个过滤器或拦截器能优先执行，就涉及到它们的执行顺序。

过滤器用`@Order`注解控制执行顺序，通过`@Order`控制过滤器的级别，值越小级别越高越先执行。

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
@Component
public class MyFilter2 implements Filter {}
```

拦截器默认的执行顺序，就是它的注册顺序，也可以通过`@Order`手动设置控制，值越小越先执行。

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new MyInterceptor2()).addPathPatterns("/**").order(2);
    registry.addInterceptor(new MyInterceptor1()).addPathPatterns("/**").order(1);
    registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").order(3);
}
```

`postHandle()` 调用顺序跟 `preHandle()` 居然是相反的！如果实际开发中严格要求执行顺序，那就需要特别注意这一点



## 8、**Redis** 与 **Memcached** 的区别

**共同点** ：

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。

**区别** ：

1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。**Memcached 只支持最简单的 k/v 数据类型**。
2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中**。
3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。
4. **Redis 在服务器内存不够时，可以将不用的数据放到磁盘上。但是，Memcached 会直接报异常**。
5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的**。
6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型**（Redis 6.0引入了多线程 IO）
7. **Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言**。
8. **Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除**。















