

技术栈

1、不够全面

2、技术分类

3、加一些中间件

项目

1、项目背景

2、项目难点

3、具体工作内容

4、重难点思考



# 自我介绍

我叫谭方川，是一名计算机专业的本科生，因为大学教授的东西不太符合企业招聘要求，所以我在招聘网站网查找企业需要的技能，大学期间自学了这些技术，例如Spring、Spring Boot、MyBatis，以更好的满足企业招聘需求。我在大学期间参加过算法竞赛并且也获得了国家级的奖项。我自己做也过一些项目，有相关的开发经验，能够快速学习一个技能并应用到项目中。生活中我是一个比较积极乐观的人，喜欢各种运动，在校期间也积极参加校各种活动。最后，很希望能够加入贵公司，谢谢。



# 项目介绍

## 校园师生服务

> `Spring Security`身份认证流程

1、用户名和密码被过滤器获取到，封装成`Authentication`，通常情况下是`UsernamePasswordAuthenticationToken`这个实现类。

2、`AuthenticationManager`身份管理器（一般是`ProviderManager`）负责验证这个`Authentication`

3、认证成功后，`AuthenticationManager`身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）`Authentication`实例。

4、`SecurityContextHolder`安全上下文容器将第 3 步填充了信息的`Authentication`保存到`SecurityContext`上下文中（实际上是一个`ThreadLocal`）

> `Spring Security`授权流程

通过各种过滤器、拦截器实现



## 分布式电商

问题：不同微服务之间的登录信息共享

**`Session`工作流程**：

1、浏览器向服务器发送请求后，服务器会生成一个`Session`，并将`Session`的 ID（`JSESSIONID`） 以`Cookie`方式返回，浏览器会保存这个`Cookie`，以后每次请求都会带着这个`Cookie`。

2、浏览器再次请求服务器时，服务器会根据`JSessionID`的值来获取对应的`Session`，从而获取保存在`Session`中的数据

3、浏览器中保存的`Cookie`都是有作用域的，作用域的范围就是域名的范围，例如`wwww.a.com`无法访问`www.b.com`中的`Cookie`，在该域名下服务器也就无法获取`Session`，也就无法获取`Session`中的数据，此时服务器就会创建一个新的`Session`，并返回`Session`的 ID。

**不同域名的`Session`共享解决方案**：

1）`hash`一致性：通过计算`hash`将某个`IP`下的请求都发送到同一个服务器

**问题**：

* 如果部分服务器宕机就会有一部分用户需要重新登录
* 重启之后`hash`值会变

2）**同一存储问题**：将所有的`Session`都存储到同一台服务器

**问题**：

* 多了一次网络交互



**`Session`的子域共享问题**：例如`mall.tfc.com`和`abc.tfc.com`无法共享`Session`，但`.tfc.com`域名下的都是可以共享的，可以用`Spring Session`来解决这个问题，在存储的时候就设置作用域。

```java
@Configuration
public class SessionConfig implements BeanClassLoaderAware {
    @Bean
	public CookieSerializer cookieSerializer() {
		DefaultCookieSerializer serializer = new DefaultCookieSerializer();
		serializer.setCookieName("JSESSIONID"); 
		serializer.setDomainName("tfc.com");     // 自定义 Session 作用域
		return serializer;
	}

    // 自定义序列化器（JSON 格式）
	@Bean
	public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
		return new GenericJackson2JsonRedisSerializer(objectMapper());
	}
}
```

> `Spring Session`原理

利用`Filter`过滤器将原生的`Request`、`Response`包装成自定义的返回



# 设计模式

## 工厂模式

创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。例如去工厂提车时，不需要知道车是怎样建造的

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行

> 过程

1、创建一个`Shape`接口，并实现它

```java
public interface Shape {
   void draw();
}
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

2、创建一个工厂，根据不同的信息创建不同的对象

```java
public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```



## 抽象工厂模式

围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂，在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

1、创建一个形状接口，及其实现类。

```java
public interface Shape {
    void draw();
}
public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Inside Rectangle::draw() method.");
    }
}
public class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Inside Square::draw() method.");
    }
}
```

2、创建一个颜色接口，及其实现类

```java
public interface Color {
    void fill();
}
public class Red implements Color {
    @Override
    public void fill() {
        System.out.println("Inside Red::fill() method.");
    }
}
public class Green implements Color {
    @Override
    public void fill() {
        System.out.println("Inside Green::fill() method.");
    }
}
```

3、创建一个抽象工厂，及其子类

```java
public abstract class AbstractFactory {
    public abstract Color getColor(String color);
    public abstract Shape getShape(String shape);
}
public class ShapeFactory extends AbstractFactory {
    @Override
    public Shape getShape(String shapeType){
        if(shapeType == null){
            return null;
        }        
        if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
        }
        return null;
    }

    @Override
    public Color getColor(String color) {
        return null;
    }
}
public class ColorFactory extends AbstractFactory {
    @Override
    public Shape getShape(String shapeType){
        return null;
    }

    @Override
    public Color getColor(String color) {
        if(color == null){
            return null;
        }        
        if(color.equalsIgnoreCase("RED")){
            return new Red();
        } else if(color.equalsIgnoreCase("GREEN")){
            return new Green();
        } else if(color.equalsIgnoreCase("BLUE")){
            return new Blue();
        }
        return null;
    }
}
```

4、创建一个工厂创造器，通过传递形状或颜色信息来获取工厂。

```java
public class FactoryProducer {
    public static AbstractFactory getFactory(String choice){
        if(choice.equalsIgnoreCase("SHAPE")){
            return new ShapeFactory();
        } else if(choice.equalsIgnoreCase("COLOR")){
            return new ColorFactory();
        }
        return null;
    }
}
```

5、使用`FactoryProducer`来获取`AbstractFactory`，通过传递类型信息来获取实体类的对象。

```java
public class AbstractFactoryPatternDemo {
    public static void main(String[] args) {
        //获取形状工厂
        AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
        //获取形状为 Circle 的对象
        Shape shape1 = shapeFactory.getShape("CIRCLE");
        //调用 Circle 的 draw 方法
        shape1.draw();

        //获取颜色工厂
        AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
        //获取颜色为 Red 的对象
        Color color1 = colorFactory.getColor("RED");
        //调用 Red 的 fill 方法
        color1.fill();
    }
}
```



## 单例模式

```java
public class Singleton {
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
}
```

* 使用`volatile`防止指令重排
* 使用`synchronize`保证多线程安全



# 计算机网络

## 子网掩码的作用

子网掩码不能单独存在，它必须结合IP地址一起使用。**子网掩码只有一个作用：将某个IP地址划分成网络地址和主机地址两部分**。通俗的话，就是用来分割子网和区分那些ip是同一个网段的，那些不是同一网段的

**将子网掩码与 IP 地址做与运算，得到的结果就是 IP 的网段** 



## TCP三次握手、四次挥手

> 三次握手

1、客户端–发送带有`SYN`标志的数据包：`Client`什么都不能确认；`Server`确认了对方发送正常，自己接收正常

2、服务端–发送带有`SYN/ACK`标志的数据包：`Client`确认了自己发送、接收正常，对方发送、接收正常；`Server`确认了对方发送正常，自己接收正常

3、客户端–发送带有带有`ACK`标志的数据包：`Client`确认了自己发送、接收正常，对方发送、接收正常；`Server`确认了自己发送、接收正常，对方发送、接收正常

> 四次挥手

1、客户端发送一个`FIN`，用来关闭客户端到服务器的数据传送

2、服务器收到这个`FIN`，它返回一 个`ACK`，确认序号为收到的序号加 1 。和`SYN`一样，一个`FIN`将占用一个序号

3、服务器收到`FIN`的信号后，可能有后续工作需要处理，处理完成后关闭与客户端的连接，发送一个`FIN`给客户端

4、客户端发回`ACK`报文确认，并将确认序号设置为收到序号加 1

**举个例子**：

* A 和 B 打电话，通话即将结束后，A 说 "我没啥要说的了"，B 回答 "我知道了"
* 但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通
* 最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 



## TCP、UDP的区别

|       | 是否面向连接 | 可靠性 |  传输形式  | 传输效率 | 所需资源 | 应用场景                     |
| :---: | :----------: | :----: | :--------: | :------: | :------: | ---------------------------- |
| `TCP` |      是      |  可靠  |   字节流   |    慢    |    多    | 要求通信数据可靠（文件传输） |
| `UDP` |      否      | 不可靠 | 数据报文段 |    快    |    少    | 要求通信速度高（语音通话）   |



## TCP 如何保证数据传输的可靠性

1、首先将数据分割为`TCP`认为最合适的大小块，也叫数据包，每个数据包都有一个编号，接收端按顺序接收

2、**校验和**：数据包中有校验字段，如果接收端根据此校验数据计算出错，则丢弃该数据包，并且接收端会丢弃重复的数据

3、**流量控制**：发送方、接收方都有一个固定大小的缓冲区，缓冲区快慢的时候接收端会提示发送端降低发送速率，方式丢包，流量控制使用**滑动窗口** 

4、**拥塞控制**：当网络拥堵时减少数据的发送

5、`ARQ`协议：发完一个分组就等待对方确认，收到确认后再发送下一个分组

6、**超时重传**：当发送一个数据后，会启动一个定时器，如果规定等待时间内没有收到确认消息，则重新发送该数据



## URI、URL 的区别

`URI`：统一资源标识符

`URL`：统一资源定位符

我们要找一个人张三，我们可以通过他的唯一的标识来找，比如说身份证，那么这个身份证就唯一的标识了一个人，这个身份证就是一个`URI`，这个标识是唯一的

而要找到张三，我们不一定要用身份证去找，我们还可以根据地址去找，如 在清华大学18号宿舍楼的404房间第一个床铺的张三，我们也可以唯一确定一个张三，而这个地址就是我们用于标识和定位的`URL` 

例如我们要请求`IP`为`192.168.30.110`下的资源，这个`IP`就是一个`URI` 

如果要请求`192.168.30.110:8080/index.html`这个资源，这个就是一个`URL` 



## HTTP、HTTPS的区别

> 端口

`HTTP`的`URL`由`“http://”`起始且默认使用端口 80，而`HTTPS`的`URL`由`“https://”`起始且默认使用端口 443

> 安全性

`HTTP`协议运行在`TCP`之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。`HTTPS`是运行在`SSL/TLS`之上的`HTTP`协议。

`HTTPS`所有传输的内容都经过加密，加密采用对称加密，**但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说，`HTTP`安全性没有`HTTPS`高，但是`HTTPS`比`HTTP`耗费更多服务器资源

**对称加密**：加密、解密都用的是同一个秘钥

**非对称加密**：私钥加密，公钥解密，公钥是可以公开的，私钥不能公开



## 浏览器输入 URL 发生的事情

1、浏览器查找域名的`IP`地址，查找过程：浏览器缓存、路由缓存、`DNS`缓存、`DNS`服务器

2、找到`IP`就找到了服务器，向服务器发送一个`HTTP`请求，`Cookie`会一起发送给浏览器

3、服务器处理请求返回`HTML`网页数据，浏览器显示数据

> 这个过程中用到的协议

`TCP`：浏览器与服务器之间是`TCP`协议

`IP`：发送数据时，需要知道下一个节点`IP`，需要`IP`协议

`OPSF`：数据包在路由器之间传输使用该协议

`ARP`：路由器在与服务器通信时，需要将`IP`转换为`MAC`地址时使用该协议

`HTTP`：在连接建立以后，使用`HTTP`协议访问网页



# Redis

## **Redis** 与 **Memcached** 的区别

**共同点** ：

1. 都是基于内存的数据库，一般都用来当做缓存使用
2. 都有过期策略
3. 两者的性能都非常高

**区别** ：

1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。**Memcached 只支持最简单的 k/v 数据类型**。
2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中**。
3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。
4. **Redis 在服务器内存不够时，可以将不用的数据放到磁盘上。但是，Memcached 会直接报异常**。
5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的**。
6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型**（Redis 6.0引入了多线程 IO）
7. **Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言**。
8. **Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除**。



## Redis持久化方式RDB、AOF

> **RDB** 

在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储

**优点**：

* redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能
* 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效

**缺点**：

* RDB方式就不太适合非常敏感的数据，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失

> **AOF** 

将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了

**优点**：

* 默认的 AOF 持久化策略是每秒钟同步一次，因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近 1 秒钟的数据
* **重写**：即当 AOF 文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集

**缺点**：

* 比如在同样数据规模的情况下，AOF文件要比 RDB 文件的**体积大**。而且，AOF方式的**恢复速度也要慢于RDB方式** 



## Redis 为什么这么快

1）完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销

2）数据结构简单，对数据操作也简单。Redis 中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。

3）采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。

4）Redis 基于 Reactor 模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器 file event handler。**由于这个文件事件处理器是单线程的，所以Redis才叫做单线程的模型，但是它采用IO多路复用机制同时监听多个Socket，并根据Socket上的事件来选择对应的事件处理器进行处理** 



## Redis 为什么是单线程

这里我们强调的单线程，指的是**网络请求模块使用一个线程来处理，即一个线程处理所有网络请求，其他模块仍用了多个线程** 



## Redis6.0之前不使用多线程原因

Redis使用单线程的可维护性高。多线程模型虽然在某些方面表现优异，但是它却**引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗**。



## Redis6.0为什么要引入多线程呢

因为 Redis 的瓶颈不在内存，而是在网络I/O模块带来CPU的耗时，所以**Redis6.0的多线程是用来处理网络I/O这部分，充分利用CPU资源，减少网络I/O阻塞带来的性能损耗**。

Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行，也就不存在并发安全问题



## Redis中键过期了会立即删除吗？

> 答案：**不会** 

如果一个很大的键值对超时，比如一个列表或者哈希结构，存在数以百万个元素，要对其回收需要很长的时间。如果采用超时回收，则可能产生停顿。坏处也很明显，这些超时的键值对会浪费比较多的空间。



## Redis键的回收策略

> 惰性回收

当 client 主动访问 key 会先对 key 进行超时判断，过时的 key 会立刻删除，然后查数据库，更新缓存

**缺点**：对内存不友好，如果一个键过期了，如果这个键永远不会被访问，那么久会造成内存浪费，甚至造成内存泄露

> 定时回收

每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，同时也减少了内存浪费

> 内存不够

当前已用内存超过 maxmemory 限定时，会触发主动清理策略，我们需要根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。

如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换(swap)会让 Redis 的性能急剧下降。

**默认策略是volatile-lru**，即超过最大内存后，在**过期键中使用lru**算法进行key的剔除，保证不过期数据不被删除，但是**可能会出现OOM问题**。

其他策略如下：

- allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止
- allkeys-random：随机删除所有键，直到腾出足够空间为止
- volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略
- noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error)。OOM command not allowed when used memory"，此时 Redis 只响应读操作

记住：**volatile 开头的策略，只清理过期的key，而 all 开头的策略则不管你过不过期，都会清理**。



## 缓存雪崩怎么解决

**缓存雪崩**：某一时刻有大面积的缓存失效，也就是数据的过期时间到了，Redis 将之删除，导致大量请求直接访问数据库

**解决办法**：

> **1）设置不同的过期时间** 

不要将大量数据设置同一个过期时间

> 2）**布隆过滤器** 

一种数据结构，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是 0，就是 1，但是初始默认值都是0。

**添加数据**：当要向布隆过滤器中添加一个元素 key 时，我们通过多个hash 函数，算出一个值 k，然后第 k 个特方格置为 1。**比如，hash(key) = 1，那么在第 2 个比特将 0 变为 1，hash(key) = 7，那么将第 8 个比特置为 1，依次类推**。

**判断数据是否存在**：对数据计算 hash 值，判断对应的比特位上是否为 1，但多个数据的 hash 值可能相同，所以如果计算结果对应位置上为 1，数据也不一定存在，但如果为 0，则肯定不存在。

**优点**：二进制组成的数组，占用内存极少，并且插入和查询速度都足够快

**缺点**：随着数据的增加，误判率会增加，无法判断数据一定存在；另外还有一个重要缺点，无法删除数据





# 多线程

## 线程池

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(...);
// 线程池七大参数
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
```

> 1、corePoolSize：核心线程数

线程池已创建就准备就绪的线程数量，等待处理异步任务，这些线程一直存在，除非设置了`allowCoreThreadTimeOut` 

> 2、maximumPoolSize：最大线数量

控制线程数量，控制资源

> 3、keepAliveTime：存活时间   unit：时间单位

如果当前存在的线程数量大于核心线程的数量，等待处理任务的**非核心线程的存活时间** 

> 4、BlockingQueue<Runnable> workQueue：阻塞队列

如果所有线程都处于工作状态，多余的任务将被存放在阻塞队列，只要有线程空闲，就从中取出任务执行

> 5、ThreadFactory threadFactory：线程创建工厂

可以自定义，也可以用默认的

> 6、RejectedExecutionHandler handler

如果阻塞队列满了，就按照指定的拒绝策略拒绝执行任务



## 一个任务进入线程池执行流程

1、如果核心线程有空闲，就交给核心线程执行

2、如果核心线程都处于工作状态，就放入阻塞队列

3，如果阻塞队列满了且核心线程都处于工作状态，就开启一个新的线程执行任务

4、如果线程数量达到最大值，就执行拒绝策略



## 实现线程安全的方法有哪几种

* 使用线程安全的类，JUC包下的类
* 使用 synchronize 修饰
* lock接口
* volatile + CAS【单纯的volatile是轻量级的同步机制保证可见性但是不具备原子性所以要配合CAS来实现线程安全】
* atomic 原子类



## violation的特点

由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，**因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存**。

**高速缓存**：将主存中的数据复制一份放到CPU高速缓存中，CPU操作高速缓存速度远比操作主存快，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中

这对于单线程来说没有问题，但对于多线程来说就有点问题，例如有线程 A 和线程 B，**两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程 A 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。最终结果 i 的值是 1，而不是 2**。这就是著名的**缓存一致性**问题。通常称这种被多个线程访问的变量为**共享变量**。

用`volition`修饰的关键字每次读取都从主存中读取，没有复制一份到高速缓存中



## 死锁产生原因以及解决办法

**死锁产生原因**：线程 A 持有线程 B 所需资源，线程 B 持有线程 A 所需资源，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

```java
public class Main {

    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

**如何预防死锁？** 破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件** ：一次性申请所有的资源。
2. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件** ：靠按序申请资源来预防。**按某一顺序申请资源，释放资源则反序释放**。破坏循环等待条件。

**如何避免死锁？**避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

**安全状态**：指的是系统能够按照某种进程推进顺序（P1、P2、P3.....Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。

我们对线程 2 的代码修改成下面这样就不会产生死锁了。

```java
new Thread(() -> {
    synchronized (resource1) {
        System.out.println(Thread.currentThread() + "get resource1");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread() + "waiting get resource2");
        synchronized (resource2) {
            System.out.println(Thread.currentThread() + "get resource2");
        }
    }
}, "线程 2").start();
```

我们分析一下上面的代码为什么避免了死锁的发生?

线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。



## ThreadLocal作用，会产生什么问题

**作用**：让同一个线程在任何地方都能拿到数据

```java
public class Main implements Runnable {

    // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[] args) throws InterruptedException {
        Main obj = new Main();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(obj, "" + i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("Start: Thread Name = " + Thread.currentThread().getName() + " default Formatter = " + formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("End: Thread Name = " + Thread.currentThread().getName() + " formatter = " + formatter.get().toPattern());
    }
}
```

从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样

**ThreadLocal 原理**：

```java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```

从上面`Thread`类 源代码可以看出`Thread`类中有一个`threadLocals`和 一个`inheritableThreadLocals`变量，它们都是`ThreadLocalMap`类型的变量。

我们可以把`ThreadLocalMap`理解为`ThreadLocal`类实现的定制化的`HashMap`。默认情况下这两个变量都是 null，只有当前线程调用`ThreadLocal`类的`set`或`get`方法时才创建它们，实际上调用这两个方法的时候，我们调用的是`ThreadLocalMap`类对应的`get()`、`set()`方法。 

`ThreadLocal`类的`set()`方法：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value); // 以 threadlocal 为键
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的`ThreadLocalMap`中，并不是存在`ThreadLocal`上，`ThreadLocal`可以理解为只是`ThreadLocalMap`的封装，传递了变量值。**`ThrealLocal`类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对**。



**ThreadLocal 内存泄露问题**：

`ThreadLocalMap`中使用的 key 为`ThreadLocal`的**弱引用**，而 value 是强引用。所以，如果`ThreadLocal`没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。

这样一来，`ThreadLocalMap`中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。

`ThreadLocalMap`实现中已经考虑了这种情况，在调用`set()`、`get()`、`remove()`方法的时候，会清理掉 key 为 null 的记录。使用完`ThreadLocal`方法后 最好手动调用`remove()`方法。



## 进程、线程间通信方式

**进程间的常见的通信方式**：

1）**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

2）**有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3）**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

4）**消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点**。

5）**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6）**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

7）**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

**线程间通信的同步方式**：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

* **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

* **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

* **事件(Event)**：Wait/Notify，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。



## 乐观锁、悲观锁

> **乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题**。

1）**乐观锁**：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。

`CAS`**比较并交换**：将预期值 **A** 与内存中的值 **B** 进行比较，如果两者相等，则进行业务逻辑处理，如果不相等，则将 A 更新为当前 B 的值，不断重复操作，直到业务逻辑处理完成。

**版本号机制**：基本思路是在数据中增加一个字段 **version**，表示该数据的版本号，每当数据被修改，版本号加 1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。

2）**悲观锁**：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住（`Synchronize`），直到操作完成后才会释放锁，上锁期间其他人不能修改数据。

> 竞争激烈程度

1）当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。

2）当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源



**乐观锁的缺点**：

假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：

(1) 线程 1 读取内存中数据为 A；

(2) 线程 2 将该数据修改为 B；

(3) 线程 2 将该数据修改为 A；

(4) 线程 1 对数据进行 CAS 操作

**在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题**。

在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：**一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化**。

对于 ABA 问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都 +1；在进行 CAS 操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS 才能执行成功。Java 中的 AtomicStampedReference 类便是使用版本号来解决 ABA 问题的。



## 多线程创建方式

1）继承 **Thread** 类，重写 **run** 方法

2）实现 **Runnable** 接口

3）实现 **Callable** 接口，可以有返回值



# Java 基础

## 防止表单重复提交

1）**通过 JavaScript 禁用提交按钮（不推荐）**：通过 js 代码，当用户点击提交按钮后，屏蔽提交按钮使用户无法点击提交按钮或点击无效，从而实现防止表单重复提交。**js 代码很容易被绕过，比如用户通过刷新页面方式，或使用 postman 等工具绕过前段页面仍能重复提交表单。因此不推荐此方法**。

2）**给数据库增加唯一键约束（简单粗暴）**：在数据库建表的时候在 ID 字段添加主键约束，用户名、邮箱、电话等字段加唯一性约束，确保数据库只可以添加一条数据。

3）**利用Session防止表单重复提交（推荐）**：服务器返回表单页面时，会先生成一个 token 保存于 session，并把该 token 传给表单页面。当表单提交时会带上 token，服务器拦截器 Interceptor 会拦截该请求，拦截器判断 session 保存的 token 和表单提交token 是否一致，若不一致或 session 的 token 为空或表单未携带 token 则不通过。

首次提交表单时 session 的 token 与表单携带的 token 一致走正常流程，然后拦截器内会删除 session 保存的 token 。当再次提交表单时由于 session 的 token 为空则不通过。从而实现了防止表单重复提交。

4）**使用Post/Redirect/Get模式**：在提交后执行页面重定向，这就是所谓的[Post-Redirect-Get (PRG)]()模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。



## 用 final 修饰的特点

- `final`类不能被继承，没有子类，final类中的方法默认是final的。 
- `final`方法不能被子类的方法覆盖，但可以被继承。 
- `final`成员变量表示常量，只能被赋值一次，赋值后值不再改变。 
- `final`不能用于修饰构造方法。



## 泛型

泛型：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。在定义一个类、接口或者方法时可以**指定类型参数**。这个类型参数我们可以在使用类、接口或者方法时**动态指定**。

泛型擦除：Java中的泛型**只在编译期有效，在运行期间会被删除**。也就是说所有泛型参数在编译后都会被清除掉

```java
public class Foo {  
    public void listMethod(List<String> stringList){  
    }  
    public void listMethod(List<Integer> intList) {  
    }  
}
```

上面这段代码编译时会报方法重载错误，原因是上面两个方法的**参数是泛型参数，在编译后会被泛型擦除**，最后两个方法都会是 **public void listMethod(List intList)**，所以会报重载错误的

```java
public static void main(String[] args) throws Exception {
    List<Integer> list = new ArrayList<>();
    list.add(12);
    
    list.add("aaaaa") // 这里直接添加字符串类型数据会报错

    Class<? extends List> clazz = list.getClass();
    Method add = clazz.getDeclaredMethod("add", Object.class);
    add.invoke(list, "aaaaa"); // 通过反射调用添加字符串类型数据不会报错，因为运行时泛型信息被擦除了
    
    System.out.println(list);
}
```



## static作用

所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在

被static修饰的成员变量和成员方法独立于该类的任何实例对象。也就是说，**它不依赖类特定的实例，被类的所有实例共享**。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。



## 内存溢出、内存泄漏

**内存溢出**：指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存** 

**内存泄漏**：程序运行过程中**某些对象或变量用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序



## synchronize 原理

1、修饰代码块：在代码的前后各有一个`monitorenter`、`monitorexit` 

* 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++ 实现的，由`ObjectMonitor`实现的。每个对象中都内置了一个 `ObjectMonitor`对象

* 另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因

在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0,则表示锁可以被获取，获取后将锁计数器加 1

在执行`monitorexit`指令后，将锁计数器减 1，表明锁被释放，其他线程可以尝试获取锁

2、修饰方法：`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁



## private 关键字的意义

1、private 并非解决安全问题的，若是想让解决代码的安全问题，请用别的办法

2、private 的意义是`OOP`（面向对象编程）的封装概念，只是为了表达封装这个概念，就是个约定而已

**防君子不防小人** 



## 一个Java文件写多个类编译的结果

有几个类就有几个 **class** 



## switch 关键字

1、`JDK 1.5`之前，`switch`循环只支持`char、byte、short、int`四种数据类型

2、`JDK 1.5`开始，`switch`循环中增加了枚举类与`byte short char int`的包装类

* 对四个包装类的支持是因为`java`编译器在底层手动进行拆箱
* 对枚举类的支持是因为枚举类有一个`ordinal`方法,该方法实际上是一个`int`类型的数值

3、`JDK 1.7`开始，`switch`循环支持`String`类型，但实际上`String`类型有一个`hashCode`算法，结果也是`int`类型，而`byte short char`类型可以在不损失精度的情况下向上转型成`int`类型，**所以总的来说，可以认为`switch`中只支持`int`** 



## 解释面向对象

当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说**这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决**。



## float

Java 中小数默认是 double 类型，如果要声明一个 float 类型变量，必须在最后添加一个`f`，以示区别



## 有了字节流，为什么还要字符流？

字符流是`Java`虚拟机转换字节得到的，这个过程非常耗时，并且如果不知道编码的话很容易出现乱码问题，所以干脆直接提供一个操纵字符的接口，方便对字符的操作。但是音频、图片等媒体文件用字节流比较好。



## try-catch-finally

无论是否捕获或处理异常，`finally`块里的语句都会被执行。当在`try`块或`catch`块中遇到`return`语句时，`finally`语句块将**在方法返回之前被执行**。

**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句不会被执行。



# Spring

## 什么是 Spring

Spring 是一个轻量级开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为企业应用程序开发提供集成的框架

Spring 使用基本的 JavaBean 来完成以前只可能由EJB(Enterprise Java Beans)完成的事情。任何 Java 应用都可以从 Spring 中受益

Spring 的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EE full-stack(一站式) **轻量级开源框架**。



## IoC(Inversion of Control)

Spring 之前创建对象方式：使用 new 关键字手动创建，这样有些缺点

* 必须自己管理对象之间的依赖关系，管理很困难
* 哪处需要对象就要创建一个，难以复用，浪费内存

Spring 创建对象的方式：通过配置文件或注解的方式配置好需要的组件，Spring 启动时会加载配置文件、扫描相应的注解，自动帮我们创建好对象，放到`IoC`容器中，我们需要就从中取就可以了



## AOP(Aspect Oriented Programming)

面向切面编程：在不改动原有方法的基础上，在方法前后添加一些处理，例如事务处理

**原理**：动态代理



## Spring IoC容器有哪些

1）**ClassPathXmlApplicationContext**：该类从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。

```java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(String configLocation);
```

2）**FileSystemXmlApplicationContext**：该类从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。

```java
ApplicationContext applicationContext = new FileSystemXmlApplicationContext(String configLocation);
```

3）**AnnotationConfigApplicationContext**：该类扫描指定的包路径或指定的类来寻找需要实例化的类

```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(String configLocation);
```



## Spring Bean生命周期

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对将 Bean 的引用和值注入到 Bean 的属性中
3. 如果Bean实现了**BeanNameAware**接口的话，Spring将**Bean的Id**传递给setBeanName()方法
4. 如果Bean实现了**BeanFactoryAware**接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了**ApplicationContextAware**接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
6. 如果Bean实现了**BeanPostProcessor**接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
7. 如果Bean 实现了**InitializingBean**接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果Bean 实现了**BeanPostProcessor**接口，Spring就将调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean 已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果bean实现了**DisposableBean**接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。

**总结**：先实例化类，创建一个对象，注入引用和属性值，设置Bean的 ID、容器、上下文，在所有属性注入成功后进行初始化，在初始化前后各有一些处理动作，这个 Bean 就可以使用了，需要销毁的时候调用销毁方法即可



## Spring Bean的作用域

|      属性      | 作用域                                                       |
| :------------: | ------------------------------------------------------------ |
|   singleton    | 在Spring IoC容器仅存在一个 Bean 实例，Bean以单例方式存在，默认值 |
|   prototype    | 每次从容器中调用 Bean 时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean() |
|    request     | 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于 WebApplicationContext 环境 |
|    session     | 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 |
| global-session | 一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境 |



## Spring循环依赖

```java
@Component
public class A {
    private B b;
    public void setB(B b) {
        this.b = b;
    }
}
@Component
public class B {
    private A a;
    public void setA(A a) {
        this.a = a;
    }
}
```

关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，一定要明白一点就是，**一个完整的对象包含两部分：当前对象实例化和对象属性的实例化**。

在Spring中，对象的实例化是通过反射实现的，而**对象的属性则是在对象实例化之后通过一定的方式设置的**。

解释：

* 当获取`A`对象时，会先创建一个空对象，然后在逐步初始化对象属性，这时候相当于一个半成品
* 实例化对象属性发现需要`B`对象，就会去创建一个空的`B`对象，也是一个半成品
* 实例化`B`的时候发现需要`A`对象，就将半成品`A`注入进来，返回创建的半成品`B`对象
* 最后`A`对象将半成品`B`对象注入，完成创建

能解决循环依赖的前提是：Spring开启了**allowCircularReferences**，那么一个正在被创建的 bean 才会被放在半成品池子里，在向容器获取 bean 的时候，优先向成品池子要，要不到，再去向半成品池子要



## Spring 中实现事务的方式

> **编程式事务管理** 

通过`TransactionTemplate`手动管理事务，实际应用中很少使用

```java
@Autowired
private TransactionTemplate transactionTemplate;

public void testTransaction() {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
            try {
                // ....  业务代码
            } catch (Exception e) {
                //回滚
                transactionStatus.setRollbackOnly();
            }
        }
    });
}
```

通过`TransactionManager`手动管理事务

```java
@Autowired
private PlatformTransactionManager transactionManager;  // 使用之前需要往容器中注入一个该接口的实现类

public void testTransaction() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
        // ....  业务代码
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
    }
}
```

`PlatformTransactionManager`：该接口中定义了事务的基本规则，具体实现由各个厂家实现

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}
```

`getTransaction()`用来获取一个事务，需要传入一个`TransactionDefinition`，该参数包含了一些事务的基本属性：传播行为、隔离级别、回滚规则、是否只读、事务超时等属性

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;

    default int getPropagationBehavior() {
        return 0;
    }

    default int getIsolationLevel() {
        return -1;
    }

    default int getTimeout() {
        return -1;
    }

    default boolean isReadOnly() {
        return false;
    }

    @Nullable
    default String getName() {
        return null;
    }

    static TransactionDefinition withDefaults() {
        return StaticTransactionDefinition.INSTANCE;
    }
}
```

`PlatformTransactionManager.getTransaction(…)`方法返回一个`TransactionStatus`对象，由该对象可以获取一些事务的设置情况

```java
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
```



> 声明式事务管理：**@Transaction** 注解

**方法** ：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效**。

**类** ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

**接口** ：不推荐在接口上使用

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    @AliasFor("transactionManager")
    String value() default "";
    @AliasFor("value")
    String transactionManager() default "";
    String[] label() default {};
    Propagation propagation() default Propagation.REQUIRED;   // 传播行为
    Isolation isolation() default Isolation.DEFAULT;          // 隔离级别
    int timeout() default -1;                                 // 超时时间
    String timeoutString() default "";
    boolean readOnly() default false;                         // 是否只读
    Class<? extends Throwable>[] rollbackFor() default {};    // 回滚规则
    String[] rollbackForClassName() default {};
    Class<? extends Throwable>[] noRollbackFor() default {};
    String[] noRollbackForClassName() default {};
}
```

`propagation`传播行为：在`TransactionDefinition`定义中包括了表示传播行为的常量，不过如此，为了方便使用，Spring 会相应地定义了一个枚举类`Propagation`

```java
public enum Propagation {
    REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3),NOT_SUPPORTED(4), NEVER(5), NESTED(6);

    private final int value;

    private Propagation(int value) {
        this.value = value;
    }
    public int value() {
        return this.value;
    }
}
```

1）`REQUIRED`：使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。**如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务**。

举个例子：如果我们上面的`aMethod()`和`bMethod()`使用的都是`PROPAGATION_REQUIRED`传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}
Class B {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void bMethod {
       //do something
    }
}
```

2）`REQUIRES_NEW`：**创建一个新的事务，如果当前存在事务，则把当前事务挂起**。也就是说不管外部方法是否开启事务，`REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。

举个例子：如果我们上面的`bMethod()`使用`REQUIRES_NEW`事务传播行为修饰，`aMethod`还是用`REQUIRED`修饰的话。如果`aMethod()`发生异常回滚，`bMethod()`不会跟着回滚，因为`bMethod()`开启了独立的事务。但是，如果`bMethod()`抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,`aMethod()`同样也会回滚，因为这个异常被`aMethod()`的事务管理机制检测到了。 

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}
Class B {
    @Transactional(propagation=propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
```

3）`NESTED`：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则该取值等价于`REQUIRED`。也就是说：

1. 在外部方法未开启事务的情况下`NESTED`和`REQUIRED`作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。

2. 如果外部方法开启事务的话，`NESTED`修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。

这里还是简单举个例子：如果`aMethod()`回滚的话，`bMethod()`和`bMethod2()`都要回滚，而`bMethod()`回滚的话，并不会造成`aMethod()`和`bMethod()2`回滚。

```java
Class A {
    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
        b.bMethod2();
    }
}
Class B {
    @Transactional(propagation=propagation.PROPAGATION_NESTED)
    public void bMethod {
       //do something
    }
    @Transactional(propagation=propagation.PROPAGATION_NESTED)
    public void bMethod2 {
       //do something
    }
}
```

4）`MANDATORY`：**如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常**（mandatory：强制性），这个使用的很少，就不举例子来说了。

5）**若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少**。

* `SUPPORTS`：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。

* `NOT_SUPPORTED`：以非事务方式运行，如果当前存在事务，则把当前事务挂起。

* `NEVER`：以非事务方式运行，如果当前存在事务，则抛出异常。



`isolation`事务隔离级别，`TransactionDefinition`接口中定义了五个表示隔离级别的常量：

```java
public interface TransactionDefinition {
    ......
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    ......
}
```

和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation` 

```java
public enum Isolation {
    DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);

    private final int value;

    private Isolation(int value) {
        this.value = value;
    }
    public int value() {
        return this.value;
    }
}
```

下面我依次对每一种事务隔离级别进行介绍：

- `DEFAULT`：使用后端数据库默认的隔离级别，MySQL 默认采用的`REPEATABLE_READ`隔离级别，Oracle 默认采用的`READ_COMMITTED`隔离级别。
- `READ_UNCOMMITTED`：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- `READ_COMMITTED`：允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- `REPEATABLE_READ`：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- `SERIALIZABLE`：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



`timeout`事务超时：一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在`TransactionDefinition`中以 int 的值来表示超时时间，其单位是秒，默认值为 -1，永不超时。



`readOnly`事务只读：对于只有读取数据查询的事务，可以指定事务类型为 **readonly**，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。

很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？

> MySQL 默认对每一个新建立的连接都启用了`autocommit`模式。在该模式下，每一个发送到 MySQL 服务器的`sql`语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。 

但是，如果你给方法加上了`Transactional`注解的话，这个方法执行的**所有`sql`会被放在一个事务中**。如果声明了只读事务的话，数据库就会去优化它的执行。如果不加`Transactional`，每条`sql`会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。

* 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；

* 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。



`rollbackFor`事务回滚规则：这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（**RuntimeException** 的子类）时才会回滚，**Error** 也会导致事务回滚，但是，在遇到检查型（**Checked**）异常时不会回滚。

如果你想要回滚你定义的特定的异常类型的话，可以这样：

```java
@Transactional(rollbackFor = MyException.class)
```



## Spring处理请求流程

**流程说明（重要）**：

1）客户端（浏览器）发送请求，直接请求到`DispatcherServlet`。

2）`DispatcherServlet`根据请求信息调用`HandlerMapping`，根据`URL`解析并生成对应的`Handler`处理器返回。

3）解析到对应的`Handler`（也就是我们平常说的`Controller`控制器）后，开始由`HandlerAdapter`适配器处理，如：参数封装，数据格式转换，数据验证等操作

4）`HandlerAdapter`会根据`Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。

5）处理器处理完业务后，会返回一个`ModelAndView`对象，`Model`是返回的数据对象，`View`是个逻辑上的`View`。

6）`ViewResolver`会根据逻辑`View`查找实际的`View`。

7）`DispaterServlet`把返回的`Model`传给`View`（视图渲染）。

8）把`View`返回给请求者（浏览器）



## 拦截器、过滤器

> 过滤器（**Filter**）

过滤器的配置比较简单，直接实现`Filter`接口即可，也可以通过`@WebFilter`注解实现对特定`URL`拦截，看到`Filter`接口中定义了三个方法。

- `init()`：该方法在容器启动初始化过滤器时被调用，它在`Filter`的整个生命周期只会被调用一次。**注意：这个方法必须执行成功，否则过滤器会不起作用**。
- `doFilter()`：容器中的每一次请求都会调用该方法，`FilterChain`用来调用下一个过滤器`Filter`。
- `destroy()`： 当容器销毁过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器`Filter`的整个生命周期也只会被调用一次



```java
@Component
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("Filter 前置");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("Filter 处理中");
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {
        System.out.println("Filter 后置");
    }
}
```

> 拦截器（**Interceptor**）

拦截器是**链式调用**，一个应用中可以同时存在多个拦截器`Interceptor`， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。

首先编写一个简单的拦截器处理类，请求的拦截是通过`HandlerInterceptor`来实现，看到`HandlerInterceptor`接口中也定义了三个方法。

- `preHandle()`：这个方法将在请求处理之前进行调用。**注意：如果该方法的返回值为`false`，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行**。
- `postHandle()`：只有在`preHandle()`方法返回值为`true`时才会执行。会在**Controller** 中的方法调用之后，**DispatcherServlet** 返回渲染视图之前被调用。 **有意思的是**：`postHandle()`方法被调用的顺序跟`preHandle()`是相反的，先声明的拦截器`preHandle()`方法先执行，而`postHandle()`方法反而会后执行。
- `afterCompletion()`：只有在`preHandle()`方法返回值为`true`时才会执行。在整个请求结束之后， **DispatcherServlet** 渲染了对应的视图之后执行。

```java
@Component
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        System.out.println("Interceptor 前置");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

        System.out.println("Interceptor 处理中");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

        System.out.println("Interceptor 后置");
    }
}
```

将自定义好的拦截器处理类进行注册，并通过`addPathPatterns`、`excludePathPatterns`等属性设置需要拦截或需要排除的`URL`。

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
    }
}
```

> 过滤器与拦截器的不同

1）**实现原理不一样**：过滤器和拦截器底层实现方式大不相同，过滤器是基于函数回调的，拦截器则是基于 Java 的反射机制（动态代理）实现的

在我们自定义的过滤器中都会实现一个`doFilter()`方法，这个方法有一个`FilterChain`参数，而实际上它是一个回调接口。`ApplicationFilterChain`是它的实现类， 这个实现类内部也有一个`doFilter()`方法就是回调方法。

```java
public interface FilterChain {
    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;
}
```

`ApplicationFilterChain`里面能拿到我们自定义的`xxxFilter`类，在其内部回调方法`doFilter()`里调用各个自定义`xxxFilter`过滤器，并执行`doFilter()`方法。

```java
public final class ApplicationFilterChain implements FilterChain {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response) {
            ...//省略
            internalDoFilter(request,response);
    }
 
    private void internalDoFilter(ServletRequest request, ServletResponse response){
    if (pos < n) {
            //获取第pos个filter    
            ApplicationFilterConfig filterConfig = filters[pos++];        
            Filter filter = filterConfig.getFilter();
            ...
            filter.doFilter(request, response, this);
        }
    }
}
```

而每个`xxxFilter`会先执行自身的`doFilter()`过滤逻辑，最后在执行结束前会执行`filterChain.doFilter()`，也就是回调`ApplicationFilterChain`的`doFilter()`方法，**以此循环执行实现函数回调**。

2）**使用范围不同**：

* 我们看到过滤器实现的是`javax.servlet.Filter`接口，而这个接口是在`Servlet`规范中定义的，也就是说过滤器`Filter`的使用要依赖于`Tomcat`等容器，导致它只能在`web`程序中使用。

* 而拦截器它是一个`Spring`组件，并由`Spring`容器管理，并不依赖`Tomcat`等容器，是可以单独使用的。不仅能应用在`web`程序中，也可以用于`Application`、`Swing`等程序中。

3）**触发时机不同**：

![image-20220211213059498](https://cdn.jsdelivr.net/gh/tfcCode/image/img/202202112130780.png)

过滤器`Filter`是在请求进入容器后，但在进入`servlet`之前进行预处理，请求结束是在`servlet`处理完以后。

拦截器`Interceptor`是在请求进入`servlet`后，在进入`Controller`之前进行预处理的，`Controller`中渲染了对应的视图之后请求结束。

4）**拦截的请求范围不同**：

过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对`Controller`中请求或访问`static`目录下的资源请求起作用。

5）**注入Bean情况不同**：

在过滤器中注入 **Service** 不会有什么问题，但是在拦截器中注入`service`，发起请求测试一下 ，竟然TM的报错了，`debug`跟一下发现注入的`service`怎么是`Null`啊？**这是因为加载顺序导致的问题，拦截器加载的时间点在`springcontext`之前，而`Bean`又是由`spring`进行管理**。

解决方案也很简单，我们在注册拦截器之前，先将`Interceptor`手动进行注入。**注意**：在`registry.addInterceptor()`注册的是`getMyInterceptor()`实例。

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Bean
    public MyInterceptor getMyInterceptor(){
        System.out.println("注入了MyInterceptor");
        return new MyInterceptor();
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 这里注册方式是调用方法，不是直接 new 对象
        registry.addInterceptor(getMyInterceptor()).addPathPatterns("/**");
    }
}
```

6）**控制执行顺序不同**：

实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，不过，有时我们希望某个过滤器或拦截器能优先执行，就涉及到它们的执行顺序。

过滤器用`@Order`注解控制执行顺序，通过`@Order`控制过滤器的级别，值越小级别越高越先执行。

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
@Component
public class MyFilter2 implements Filter {}
```

拦截器默认的执行顺序，就是它的注册顺序，也可以通过`@Order`手动设置控制，值越小越先执行。

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new MyInterceptor2()).addPathPatterns("/**").order(2);
    registry.addInterceptor(new MyInterceptor1()).addPathPatterns("/**").order(1);
    registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").order(3);
}
```

`postHandle()`调用顺序跟`preHandle()`居然是相反的！如果实际开发中严格要求执行顺序，那就需要特别注意这一点



# Spring Boot

## 什么是 Spring Boot？

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简化了繁重的配置，提供了各种启动器，开发者能快速上手。



## bootstrap、application

**对比 application 配置文件，bootstrap 配置文件具有以下几个特性**：

- boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载
- boostrap 里面的属性不能被覆盖

**bootstrap** 配置文件有以下几个应用场景：

- 使用 **Spring Cloud Config** 配置中心时，这时需要在 **bootstrap** 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息
- 一些固定的不能被覆盖的属性
- 一些加密/解密的场景



## 自动装配原理

1、点击`@SpringBootApplication`会发现该注解上标了一个`@EnableAutoConfiguration`，该注解是自动配置核心内容

2、`@EnableAutoConfiguration`导入了一个`AutoConfigurationImportSelector`类，该类实了`ImportSelector`接口，重写了`selectImports()`方法

3、`selectImports()`方法中调用了`getAutoConfigurationEntry()`方法，该方法负责加载自动配置类，这个方法会加载所有`Jar`包下`META-INF`下的`spring.factories`中配置的类，过滤掉不需要的类

**可以自己`Debug`看一看** 



## 自己实现一个 Starter

1、新建一个项目：`thread-spring-boot-starter`

2、新建一个配置类：`ThreadAutoConfiguration`，随便加一点东西

```java
@Configuration
public class ThreadAutoconfiguration {

    @Bean
    @ConditionalOnClass(ThreadPoolExecutor.class)
    public ThreadPoolExecutor executor() {
        return new ThreadPoolExecutor(5, 10, 10, TimeUnit.MINUTES, new ArrayBlockingQueue<>(100));
    }
}
```

3、在`thread-spring-boot-starter`工程的`resources`包下创建`META-INF/spring.factories`文件

4、新建工程引入`thread-spring-boot-starter`测试：

```java
@Autowired
ThreadPoolExecutor executor;

@Test
void contextLoads() {
    System.out.println(executor.getCorePoolSize());
}
```



## 启动 Spring Boot 的三种方式

1、直接在`IDE`中启动

2、打包启动：`java -jar  Jar-Name`

3、插件方式启动



# MySQL

## MySQL隔离级别，默认隔离级别

MySQL的事务隔离级别一共有四个，分别是：读未提交、读已提交、可重复读（默认）、可串行化。



## MySQL锁机制

**MyISAM 和 InnoDB 存储引擎使用的锁**：

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁

**只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁** 

SQL的更新（update）或者删除（delete）语句中未使用到索引，导致在InnoDB在对数据进行相应操作的时候必须把整个表锁起来进行检索（表锁）。而如果使用了索引的话，InnoDB 只会通过索引条件检索数据，而只锁住索引对应的行（行锁）。

> 锁算法

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：锁定一个范围，包含记录本身



## MySQL事务的四大特性

**原子性（Atomicity）**：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。

**一致性（Consistency）**：官网上事务一致性的概念是——事务必须使数据库从一个一致性状态变换到另外一个一致性状态。例如转账前后两人的总金额是不变的

**隔离性（Isolation）**：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

**持久性（Durability）**：一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。















