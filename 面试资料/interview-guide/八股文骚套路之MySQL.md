# 关键字分别是做什么用的

**order by**：排序

**limit**：分页

**having**：

* having 对筛选出的结果再次进行过滤
* having 字段必须是查询出来的，where 字段必须是数据表存在的
* where 不可以使用合计函数。一般需用合计函数才会用 having



# 讲一下左链接和右链接的区别

**左连接**：若左边的表在指定条件下在右边的表中没有对应的数据，则结果为 `null` 

**右连接**：若右边的表在指定条件下在左边的表中没有对应的数据，则结果为 `null` 



# InnoDB 和 MyISM、MEMORY 的区别是什么

* MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复
* 5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。

> 是否支持行级锁？

MyISAM 只有表级锁，**而 InnoDB 支持行级锁和表级锁，默认为行级锁**。也就说，MyISAM 一锁就是锁住了整张表，InnoDB 只锁住某一条记录，这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！

> 是否支持事务？

* MyISAM 不提供事务支持。

* InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力

> 是否支持外键？

MyISAM 不支持，而 InnoDB 支持

> 是否支持MVCC？

MyISAM 不支持，而 InnoDB 支持。**MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能**。



# 索引所采用的数据结构

> Hash表

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O(1) ）

但是！哈希算法有个 **Hash 冲突** 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 **链地址法**。链地址法就是将哈希冲突数据存放在链表中。

**为什么MySQL 没有使用其作为索引的数据结构呢？**

**1、Hash 冲突问题** ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。

**2、Hash 索引不支持顺序和范围查询：** 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

试想一种情况：

```sql
SELECT * FROM tb1 WHERE id < 500;
```

在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。

> B树、B+树

B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

**B 树& B+树两者有何异同呢？** 

* B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。

* B 树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

* B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。



# 聚簇索引、非聚簇索引

> 聚簇索引

**聚簇索引**：索引和数据放在一起，`B+` 数就是聚簇索引，非叶子节点存储 `key`，叶子节点存储 `value`，**主键索引是聚簇索引**

**优点**：聚集索引的查询速度非常的快，因为整个 `B+` 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

**缺点**：

* **依赖于有序的数据**：因为 `B+` 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。

* **更新代价大**：如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

> 非聚簇索引

**索引和数据分开放**，二级索引属于非聚簇索引，**唯一索引，普通索引，前缀索引等索引属于二级索引** 

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键，也就是说，通过二级索引，可以定位主键的位置** 

**优点**：**更新代价比聚簇索引要小** 。非聚簇索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

**缺点**：

* 跟聚集索引一样，非聚集索引也依赖于有序的数据
* **可能会二次查询（回表）**：这应该是非聚集索引最大的缺点了，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询

**非聚集索引不一定回表查询**：如果想查询 `name` 字段，而刚好创建了 `name` 字段的索引，则查询 `name` 字段时直接返回即可，这种情况叫**覆盖索引** 



# 在数据库中创建索引的原则

**1、选择合适的字段创建索引**：

- **不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 `0, 1, true, false` 这样语义较为清晰的短值或短字符作为替代
- **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2、被频繁更新的字段应该慎重建立索引** 

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3、尽可能的考虑建立联合索引而不是单列索引** 

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的

如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4、注意避免冗余索引** 

冗余索引指的是索引的功能相同，能够命中索引`(a, b)`就肯定能命中索引`(a)`，那么索引`(a)`就是冗余索引

如`（name,city ）`和`（name ）`这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。





7、BTree 索引和 Hash 索引的适用范围。



8、优化 SQL 语句的步骤有哪些。

9、哪些场景可以使用索引。

10、索引在哪些情况会失效。





11、事务四大特性，并解释这四大特性的含义。

12、并发事务处理会带来哪些问题？

13、事务隔离级别。

14、InnoDB 行锁实现方式

15、你了解 Next-key 锁吗？

16、如何避免 InnoDB 中的死锁。

17、数据库多版本并发控制（MVCC 机制）



