## Java 基础面试准备

下面这些问题都是面试互联网大厂后端岗位时的常问问题，我希望你都能熟练的答出来呀！暂时没记牢也不用太担心，我建议你在投简历和约面时，把最想去的公司的面试稍微往后推一推，先面几家自己拿不到 offer 也不会难过的公司。上面这些八股文就是通过我 平时+面试 记熟的，去年 7月 初第一次我面一家中小厂，这些都磕磕绊绊的答不出来，但是到后期 8月底 9月初完全能轻松应对各大厂面试官了。

另外，我通过打星与加粗的方式对下面面试题的重要性进行评级！难度是针对互联网大厂的。

- ⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。
- ⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。
- ⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。
- ⭐⭐⭐⭐：面试高频考点。
- ⭐⭐⭐⭐⭐：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问到这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。

**Java 基础常见面试题汇总** ：

1、Java 语言的特点（如果你简历上有提到 C++ 可能还会问你 Java 和 C++ 的区别）。【⭐⭐】

* 简单易学；

* 面向对象（封装，继承，多态）；

* 平台无关性（ Java 虚拟机实现平台无关性）；

* 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；

* 可靠性；

* 安全性；

* 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；

* 编译与解释并存；



2、比较 JVM 和 JDK 以及 JRE 。【⭐⭐⭐】非常非常基础的一个问题！学了 Java 之后还不知这个问题如何回答的小伙伴自觉去面壁吧！

* **JVM**：运行 Java 字节码（**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。** 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已）
* **JRE**：Java 运行时环境，如果只需要运行一个 Java 程序，只需要 **JRE** 就够了，它是运行**已编译 Java 程序**所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序
* **JDK**：它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序



3、为什么说 Java 语言“解释与编译并存”。【⭐⭐】

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤：

* 编译：由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件）
* 解释：这种字节码必须由 Java 解释器来解释执行



4、Java 基本类型有哪几种，各占多少位？【⭐⭐】前些年面试常问的一个问题，去年面试过程中只京东问我了

* byte：1字节
* short：2字节
* int：4字节
* long：8字节
* float：4字节
* double：8字节
* char：2字节



5、Java 泛型，类型擦除。【⭐⭐⭐】

泛型：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。在定义一个类、接口或者方法时可以**指定类型参数**。这个类型参数我们可以在使用类、接口或者方法时**动态指定**。

泛型擦除：Java中的泛型**只在编译期有效，在运行期间会被删除**。也就是说所有泛型参数在编译后都会被清除掉

```java
public class Foo {  
    public void listMethod(List<String> stringList){  
    }  
    public void listMethod(List<Integer> intList) {  
    }  
}
```

上面这段代码编译时会报方法重载错误，原因是上面两个方法的**参数是泛型参数，在编译后会被泛型擦除**，最后两个方法都会是 **public void listMethod(List intList)**，所以会报重载错误的



6、`==` 和 `equals()` 的区别。【⭐⭐⭐】：这个问题在 2018 年之前几乎是面试必问的问题，但是现在大厂以及比较少问了，现在小厂中厂问的多。

- 对于基本数据类型来说，`==` 比较的是值
- 对于引用数据类型来说，`==` 比较的是对象的内存地址

`equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类。

* **类没有覆盖 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。

* **类覆盖了 `equals()`方法** ：一般我们都覆盖 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)



7、`hashCode()` 和 `equals()` 【⭐⭐⭐⭐】：这个问题经常问，面试官经常问为什么重写 `equals()` 时要重写 `hashCode()` 方法？另外，这个问题经常结合着 `HashSet` 问。

**hashCode()** 用来确定元素在散列表中的位置，因此 **hashCode() 在散列表中才有用，在其它情况下没用**，散列表指的是：Java集合中本质是散列表的类，如 **HashMap，Hashtable，HashSet** 

如果两个对象相等，则 **hashCode()** 一定相等，但是如果两个对象的 **hashCode()** 不相等，这两个对象也不一定不相等，必须再由 **equals()** 进行判断是否真的相等。

例如 **HashSet** 的去重功能：会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与**已经加入的对象的 `hashCode` 值作比较**，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现，但是如果发现有相同 `hashCode` 值的对象，会进一步调用 **equals()** 进行比较是否真的相等，如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。



8、**重载和重写的区别。** 【⭐⭐⭐⭐】

* 重载：方法名相同，但返回值不同或参数列表不同
* 重写：继承父类，重写父类方法，方法的方法名、返回值、参数列表必须和父类相同；实现接口也一样。



9、深拷贝和浅拷贝。【⭐】

**浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

**深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。



10、面向对象和面向过程的区别。【⭐⭐⭐】

**面向过程**：面向过程是一种**以过程为中心**的编程思想，它首先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，在使用时依次调用，是一种基础的**顺序思维方式**。**性能比较好** 

**面向对象**：面向对象是一种**以“对象”为中心**的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。**易维护、易扩展、易复用，性能较低** 



11、成员变量与局部变量的区别。【⭐⭐⭐】

* 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。
* 成员变量属于类，存放在堆中；局部变量存放在栈中
* 成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
* 成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。



12、面向对象三大特性是什么。并解释这三大特性。【⭐⭐⭐⭐】

* **封装**：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但**是可以提供一些可以被外界访问的方法来操作属性** 

* **继承**：不同类型的对象，相互之间经常有一定数量的共同点。可以抽取出公共点作为基类，其他对象继承该类，不必每次都写一些冗余信息

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。

2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

3. 子类可以用自己的方式实现父类的方法（重写）。

* **多态**：表示一个对象具有多种的状态，具体表现为**父类的引用指向子类的实例**。

1. 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；

2. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；

3. 多态不能调用“只在子类存在但在父类不存在”的方法；

4. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法



13、`String`、`StringBuffer` 和 `StringBuilder` 的区别。【⭐⭐⭐⭐】

**String** 底层使用 `final` 修饰的字符数组来存储数据，使用 `final` 修饰的内容是不可变的（此处是对象引用），但字符数组的内容是可变的，`String` 真正不可变有下面几点原因：

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类**没有提供/暴露修改这个字符串的方法**。

2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

> 在 Java 9 之后，`String` 、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。

`StringBuilder` 与 `StringBuffer` 都使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是还提供了很多修改字符串的方法比如 `append` 方法。

`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。

`StringBuffer`、`StringBuilder`每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。



14、Java 异常。【⭐⭐⭐】：不会问的特别细。经常的问法是异常可以分为哪几种，然后你答了可检查异常和不可检查异常以后，会让你举例可检查异常有哪些，不可检查有哪些。然后，异常的代码要会写，有一场字节的面试，直接让我写一个把异常捕获了然后抛出去的代码。

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。

`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。

`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。

- `Exception` :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。
- `Error` ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获。例如，Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

**受检查异常**：如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。比如 IO 操作的代码。
除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常。
常见的受检查异常有：IO 相关的异常、`ClassNotFoundException` 、`SQLException` 等

**不受检查异常**：我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常
常见的不受检查异常：空指针异常、类型转换异常、算数错误、数组越界等



15、序列化和反序列化【⭐⭐】

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

- **序列化**：将数据结构或对象转换成**二进制字节流**的过程
- **反序列化**：将二进制字节流转换成数据结构或者对象的过程

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

* `transient` 只能修饰变量，不能修饰类和方法。

* `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。

* `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



16、反射【⭐⭐】面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景。

> 运行时分析类以及执行类中方法的能力，通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性

- **优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
- **缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查。另外，反射的性能也要稍差点

应用场景：动态代理、注解



17、`List`、`Set`、`Map`、`Queue` 的区别。【⭐⭐】

`List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。

`Set`(注重独一无二的性质): 存储的元素是无序的、不可重复的。

`Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。

`Map`(用 key 来搜索的专家): **使用键值对（key-value）存储**，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。



18、`ArrayList` 和 `LinkedList` 的区别。【⭐⭐⭐⭐】：答清楚每个分别采用什么数据结构，对比相应的优点和缺点。

* 都是线程不安全的
* `Arraylist` 底层使用的是 `Object` 数组；`LinkedList` 底层使用的是**双向链表**数据结构

* 默认插入都不影响性能，插入/删除指定位置时间复杂度为 O(n)
* `ArrayList` 支持随机访问，**LinkedList** 不支持随机访问

* `ArrayList` 的空间浪费主要体现在在 list **列表的结尾会预留一定的容量空间** 
* `LinkedList` 的空间花费则体现在它的每一个元素都需要消耗比 `ArrayList` 更多的空间



19、比较 `HashSet`、`LinkedHashSet` 和 `TreeSet` 三者的异同。【⭐⭐⭐】

> 相同点

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。

> 不同点

* `HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。
* `LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。
* `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。



20、`HashMap` 多线程操作导致死循环问题。【⭐⭐⭐】jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 `HashMap`,因为多线程下使用 `HashMap` 还是会存在其他问题比如数据丢失。并发环境下推荐使用 `ConcurrentHashMap` 

如果空间不够，需要扩容，这时需要重新计算所有元素的 hash 值，而在于并发下的 Rehash 会造成元素之间会形成一个循环链表，造成死循环



21、`HashMap` 的长度为什么是 2 的幂次方。【⭐⭐⭐】主要是考虑到了对运算效率的提升。

如果使用 % 取余操作的话，若 length 是 2 的幂次方，则 **hash % length == hash&(length - 1)**，而位运算效率较高



22、`HashMap`、`HashTable`、以及 `ConcurrentHashMap` 的区别。【⭐⭐⭐⭐⭐】：现在面试的超高频考点。当面试官问到这个问题的时候，展现你背面试八股文能力的机会来了。你可以展开去讲在 Java7 和 Java8 中 `HashMap` 分别采用什么数据结构，为什么 Java8 把之前的`头插法`改成了`尾插法`，怎样实现`扩容`，为什么`负载因子`是 `0.75`，为什么要用`红黑树`等等一系列的东西。只要面试官不打断我，我在这个知识点上能背到面试官下班。

> **对 Null key 和 Null value 的支持** 

* `HashMap` 可以存储 null 的 key 和 value，**但 null 作为键只能有一个，null 作为值可以有多个** 
* `Hashtable` 不允许有 null 键和 null 值，否则会抛出 `NullPointerException` 

> **初始容量大小和每次扩充容量大小的不同** 

创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍

创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小

> **底层数据结构** 

JDK 1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，会将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

将链表转换成红黑树前会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容**，而不是转换为红黑树

JDK 1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK 1.8 采用的数据结构跟 `HashMap 1.8` 的结构一样，数组+链表/红黑二叉树

`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的

> **是否线程安全？** 

`HashMap` 是非线程安全的

`ConcurrentHashMap` 是线程安全的

* **在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）** 对整个桶数组进行了分割分段(`Segment`)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

* **到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。** 
* `synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰

* `Hashtable` 使用 `synchronized` 来保证线程安全，效率非常低下。当多个线程访问同步方法时，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低

> **效率** 

因为线程安全的问题，`HashMap` 要比 `ConcurrentHashMap` 效率高一点，`ConcurrentHashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；





