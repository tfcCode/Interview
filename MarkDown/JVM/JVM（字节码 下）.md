# 	--------- 字节码与类的加载 -----------



# 一、Class 文件结构

## 1、概述

> **Java**：跨平台的语言

* 当 **Java** 源代码成功編译成字节码后，如果想在不同的平台上面运行，则无须再次编译
* 这个优势不再那么吸引人了。 **Python、PHP、Perl、Ruby、Lisp** 等有强大的解释器
* 跨平台似乎已经快成为一门语言必选的特性



> **Java** 虚拟机：跨语言的平台

Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 "Class" 文件这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虛拟机上执行。可以说，统一而强大的 class 文件结构，就是 Java 虚拟机的基石、桥梁

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-22_14-57-35.png)



## 2、前端编译器

**Java** 源代码的编译结果是字节码，那么肯定需要有一种编译器能够将 **Java** 源码编译为字节码，承担这个重要责任的就是配置在 **path** 环境变量中的 **javac** 编译器。 **javac** 是一种能够将 Java 源码编译为字节码的**前端编泽器** 

**HotSpot VM** 并没有制要求前端編译器只能使用 **javac** 来編译字节码，其实只要编译结果符合 **JVM** 规范都可以被 **JVM** 所识别即可

在 Java 的前端编译器领域，除了 **javac** 之外，还有一种被大家经常用到的前端编译器，那就是内置在 **Eclipse** 中的 **ECJ（Eclipse Compiler for Java）**。和 **javac** 的**==全量式==**编译不同，**ECJ** 是一种增量式编译器

* 在 Eclipse 中，当开发人员編写完代码后，使用 "Ctrl + S" 快捷键时，ECJ 編译器所釆取的鳊译方寀是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此 ECJ 的编译效率会比 Javac 更加迅速和高效，当然编译质量和 Javac 相比大致还是一样的
* 默认情况下，**IDEA 使用 Javac 編译器**（也还可以自己设置为 **AspectJ** 編译器 **AJC** ）



> 前端编译器并不会直接涉及编译优化等方面的技术，而是将这些**==具体优化细节移交给 HotSpot 的 JIT 编译器==**负责



## 3、Java 虚拟机的基石：Class 文件

> 字节码文件里是什么？

源代码经过编译器编译之后使会生成一个字节码文件，**字节码是一种二进制的类文件**，它的内容是 JVM 的指令，而不像 **C、C++ 经由编译器直接生成==机器码==** 



> 什么是字节码指令（byte code）

Java 虚拟机的指令由**一个字节长度的、代表着某种特定操作含义的==操作码==（ opcode）**以及跟随其后的零至多个代表此操作所需参数的**==操作数==**（ operand）所构成。**拟机中许多指令并不包含操作数，只有一个操作码** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-22_16-36-52.png)





## 4、Class 文件结构

> class 文件格式

Class的结枃不像 XML 等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变

**class** 文件格式采用一种**类似于 C 语言结构体**的方式进行数据存储，这种结构中只有两种数握型：**无符号数、表** 

* **无符号数**属于基本数据类型，以 **u1、u2、u4、u8** 来分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值、按照 **UTF8** 编码构成字符串值
* **表**是由多个无符号数或者其他表作为数据项构成的复合数据类型，**所有表都习惯性地以 "_info" 结尾**。表用于描述有层次关系的复合结构的数据，整个 **class** 文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明



> Class 文件的总体结构

**Class** 文件的结构并不是一成不变的，随者 **Java** 虚拟机的不断发展，总是不可避免地会对 **Class** 文件结构做出一些调整，但是基本结构和框架是非常稳定的

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-22_17-26-15.png)



| 类型           | 名称                | 说明                   | 长度    | 数量                  |
| -------------- | ------------------- | ---------------------- | ------- | --------------------- |
| u4             | magic               | 魔数,识别Class文件格式 | 4个字节 | 1                     |
| u2             | minor_version       | 副版本号(小版本)       | 2个字节 | 1                     |
| u2             | major_version       | 主版本号(大版本)       | 2个字节 | 1                     |
| u2             | constant_pool_count | 常量池计数器           | 2个字节 | 1                     |
| cp_info        | constant_pool       | 常量池表               | n个字节 | constant_pool_count-1 |
| u2             | access_flags        | 访问标识               | 2个字节 | 1                     |
| u2             | this_class          | 类索引                 | 2个字节 | 1                     |
| u2             | super_class         | 父类索引               | 2个字节 | 1                     |
| u2             | interfaces_count    | 接口计数器             | 2个字节 | 1                     |
| u2             | interfaces          | 接口索引集合           | 2个字节 | interfaces_count      |
| u2             | fields_count        | 字段计数器             | 2个字节 | 1                     |
| field_info     | fields              | 字段表                 | n个字节 | fields_count          |
| u2             | methods_count       | 方法计数器             | 2个字节 | 1                     |
| method_info    | methods             | 方法表                 | n个字节 | methods_count         |
| u2             | attributes_count    | 属性计数器             | 2个字节 | 1                     |
| attribute_info | attributes          | 属性表                 | n个字节 | attributes_count      |



### magic number：魔数

每个 Class 文件开头的 4 个宇节的无符号整数称为魔数（ Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 class 文件的标识符。**魔数值固定为 0xCAFEBABE。不会改变** 

使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，**因为文件扩展名可以随意地改动** 



### Class 文件的版本号

紧接着魔数的 **4** 个字节`存储的是 **Class 文件的版本号**。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 **minor version**，而第 7 个和第 8 个字节就是编译的主版本号 **major version** 

它们共同构成了 **Class** 文件的格式版本号。警如某个 **Class** 文件的主版本号为 **M**，副版本号为 **m**，那么这个 **Class** 文件的格式版本号就确定为 **M.m** 

不同版本的 **Java** 编译器编译的 **Class** 文件对应的版本是不样的。目前，高版本的 **Java** 虚拟机可以执行由低版本编译的 **Class** 文件，但是低版木的 **Java** 拟机不能执行由高版本编译器生成的 **Class** 文件，否则 **JVM** 会抛错（**==向下兼容==**）

* **Class** 文件版本号和平台的对应

| 主版本（十进制） | 副版本（十进制） | 编译器版本 |
| ---------------- | ---------------- | ---------- |
| 45               | 3                | 1.1        |
| 46               | 0                | 1.2        |
| 47               | 0                | 1.3        |
| 48               | 0                | 1.4        |
| 49               | 0                | 1.5        |
| 50               | 0                | 1.6        |
| 51               | 0                | 1.7        |
| 52               | 0                | 1.8        |
| 53               | 0                | 1.9        |
| 54               | 0                | 1.10       |
| 55               | 0                | 1.11       |



### 常量池

常量池是 **Class** 文件中内容最为丰富的区域之一。常量池对 **Class** 文件中的字段和方法解析也有着至关重要的作用。随着 **Java** 虛拟机的不断发展，常量池的内容也日渐丰宫。可以说，常量池是整个 **Class** 文件的基石

常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 **u2 类型**的无符号数，代表常量池容量计数值  （**constant_ pool count**）。与 Java 中语言习惯不一样的是，这个**容量计数是从 1 而不是 0 开始的** 

| 类型    | 名称                | 说明         | 长度    | 数量                  |
| ------- | ------------------- | ------------ | ------- | --------------------- |
| u2      | constant_pool_count | 常量池计数器 | 2个字节 | 1                     |
| cp_info | constant_pool       | 常量池表     | n个字节 | constant_pool_count-1 |

由上表可见，**Class** 文件使用了一个前置的容量计数器（ **constant_ pool count**）加若干个连续的数据项  （ **constant_pool**）的形式来描述常量池内容。**我们把这一系列连续常量池数据称为常量池集合** 

**常量池表项**中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在**类加载后**进入方法区的**运行时常量池**中存放



> constant_pool_count：常量池计数器

由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示**常量池容量**的大小

常量池容量计数值（u2类型）：**从 1 开始**。表示常量池中有多少项常量。即 **constant_ pool_count=1**表示常量池中有 **0** 个常量项

通常我们写代时都是从开 0 始，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是**为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达 "不引用任何一个常池项目" 的含义**，这种情况可用索引值 0 来表示



> constant_pool：常量池表

1、**constant_pool 是一种表结构，以 1~ constant_ pool_count - 1 为索引**。表明了后面有多少个常量项

2、常量池主要存放两大类常量：**字面量（ Literal）和符号引用（ Symbolic Reference）** 

3、它包含了 Class 文件结构及其了结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 **tag byte（标记字节）** 



* 字面量
    * 文本字符串
    * 声明为 final 的常量值
* 符号引用
    * 类和接口的全限定名
    * 字段和名称的描述符
    * 方法的名称和描述符



* 全限定名

**com/atguigu/test/Demo** 这个就是类的全限定名，仅仅是**把包名的 "."  替换成 "/"**，为了使连续的多个全限定名之间不产生混淆，**在使用时最后一般会加一个 "；" 表示结束** 

* 简单名称 

简单名称是指**没有类型和参数修饰的方法或者字段名称**，上面例子中的类的 **add()** 方法和 **num** 字段的简单名称分别是 **add** 和 **num** 

* 描述符 

描述符的作用是**用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值**。根据描述符规则，基本数据类型（byte、char、 double、 float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加全限定名来表示

| 标志符 | 含义                                                 |
| ------ | ---------------------------------------------------- |
| B      | 基本数据类型byte                                     |
| C      | 基本数据类型char                                     |
| D      | 基本数据类型double                                   |
| F      | 基本数据类型float                                    |
| I      | 基本数据类型int                                      |
| J      | 基本数据类型long                                     |
| S      | 基本数据类型short                                    |
| Z      | 基本数据类型boolean                                  |
| V      | 代表void类型                                         |
| L      | 对象类型，比如：`Ljava/lang/Object;`                 |
| [      | 数组类型，代表一维数组。比如：`double[][][] is [[[D` |



Java 虚拟机在加载 Class 文件时才会进行动态链接，也就是说，**Class 文件中不会保存各个方法和字段的最终内存布局信息**，因比，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行，需要从常最池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中 

* 符号引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，**符号引用与虚拟机实现的内存布局无关**，引用的目标并不一定已经加载到了内存中

* 直接引用

直接引用可以是**直接指向目标的指针、相对移量或是一个能间定位到目标的句柄。直接引机是与虚拟机实现的内存布局相关的**，同一个符号引用在不同虛拟机实例上翻译出来的直接引用般不会相同。如果有了直接引，那说明引用的目标必定已经存在于内存之中了



> 常量池中的所有的常量

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-23_08-55-34.png)



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-23_08-56-15.png)



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-23_08-56-47.png)



> 常量池中为何要包含这些内容？

**Java** 代码在进行 **Javac** 编译的时候，并不像 C 和 C++ 那样有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接。也就是说，**在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、力法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用**。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解



### 访问标识

在常量池后，紧跟着访问标记。**该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息**，包括：这个Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示

| 标志名称       | 标志值 | 含义                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| ACC_PUBLIC     | 0x0001 | 标志为 public 类型                                           |
| ACC_FINAL      | 0x0010 | 标志被声明为 final，只有类可以设置                           |
| ACC_SUPER      | 0x0020 | 标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） |
| ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                             |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |
| ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） |
| ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                             |
| ACC_ENUM       | 0x4000 | 标志这是一个枚举                                             |



### 类索引、父类索引、接口索引集合

在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：

| 长度 | 含义                           |
| ---- | ------------------------------ |
| u2   | this_class                     |
| u2   | super_class                    |
| u2   | interfaces_count               |
| u2   | interfaces[ interfaces_count ] |

这三项数据来确定这个类的继承关系 

* 类索引用于确定这个类的全限定名
* 父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0
* 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends语句）后的接口顺序从左到右排列在接口索引集合中



> interfaces

指向常量池索引集合，它提供了一个符号引用到所有已实现的接口

由于一个类可以实现多个接口因此**需要以数组形式保存多个接口的索引**，表示**接口的每个索引也是一个指向常量池的CONSTANT_Class**（当然这里就必须是接口，而不是类）



### 字段表集合

用于描述接口或类中声明的变量。**字段（field）包括类级变量以及实例级变量**，但是不包括方法内部、代码块内部声明的局部变量。字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述

它指向常量池索引集合，它描述了每个字段的完整信息。比如**字段的标识符、访问修饰符（ public、 private或protected）、是类变量还是实例变量（ static 修饰符）、是否是常量（final 修饰符）等** 



* 注意

字段表集合中不会列出从父类或者实现的接口中继承来的字段，**但有可能列出原本 Java 代码之中不存在的字段。如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段** 

在 **Java** 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是**对于字节码来讲，如果两个字段的==描述符==不一致，那字段重名就是合法的** 



字段作为一个表，他也有自己的结构

|      类型      |       名称       |    含义    |       数量       |
| :------------: | :--------------: | :--------: | :--------------: |
|       u2       |   access_flags   |  访问标志  |        1         |
|       u2       |    name_index    | 字段名索引 |        1         |
|       u2       | descriptor_index | 描述符索引 |        1         |
|       u2       | attributes_count | 属性计数器 |        1         |
| attribute_info |    attributes    |  属性集合  | attributes_count |



字段表访问标识

我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（ **public、 private、 protected**）、**static** 修饰符 **final** 修饰符、 **volatile** 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些

|   标志名称    | 标志值 |            含义            |
| :-----------: | :----: | :------------------------: |
|  ACC_PUBLIC   | 0x0001 |     字段是否为 public      |
|  ACC_PRIVATE  | 0x0002 |     字段是否为 private     |
| ACC_PROTECTED | 0x0004 |    字段是否为 protected    |
|  ACC_STATIC   | 0x0008 |     字段是否为 static      |
|   ACC_FINAL   | 0x0010 |      字段是否为 final      |
| ACC_VOLATILE  | 0x0040 |    字段是否为 volatile     |
| ACC_TRANSTENT | 0x0080 |    字段是否为 transient    |
| ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 |
|   ACC_ENUM    | 0x4000 |      字段是否为 enum       |



字段名索引：根据字段名索引的值，查询常量池中的指定索引项即可



### 方法表集合

> 指的常量池索引集合，它完整描述了每个方法的签名

在字节码文件中，**每一个 method_info 项都对应着一个类或者接口中的方法信息**。比如方法的访问修饰符（public private或 protected），方法的返回值类型以及方法的参数信息等。如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来

另一方面， **methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法**。另一方面， methods 表有可能会出现由编译器自动添加的方法，最典型的是编译器产生的方法信息**（比如：类（接口）初始化方法<c1init>（）和实例初始化方法<init>（））** 



* 注意 

在 Java 语言中，要重载（overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，**特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合** 

正因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅以返回值的不同来对一个已有方法进行重载。但**在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存**。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中

也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同



方法表结构

|      类型      |       名称       |    含义    |       数量       |
| :------------: | :--------------: | :--------: | :--------------: |
|       u2       |   access_flags   |  访问标志  |        1         |
|       u2       |    name_index    | 字段名索引 |        1         |
|       u2       | descriptor_index | 描述符索引 |        1         |
|       u2       | attributes_count | 属性计数器 |        1         |
| attribute_info |    attributes    |  属性集合  | attributes_count |



方法表访问标志：和字段访问标志差不多，有个别不同

|   标志名称    | 标志值 |                 含义                  |
| :-----------: | :----: | :-----------------------------------: |
|  ACC_PUBLIC   | 0x0001 |      public：方法可以从包外访问       |
|  ACC_PRIVATE  | 0x0002 |     private：方法只能在本类中访问     |
| ACC_PROTECTED | 0x0004 | protected：方法可以在自身和子类中访问 |
|  ACC_STATIC   | 0x0008 |           static：静态方法            |
|   ACC_FINAL   | 0x0010 |         final：方法不能被重写         |
| ACC_VOLATILE  | 0x0040 |               volatile                |
| ACC_TRANSTENT | 0x0080 |               transient               |
| ACC_SYNCHETIC | 0x1000 |      方法是否为由编译器自动产生       |



### 属性表集合

属性表的每个项的值必须是 **attribute_info 结构**。属性表的结构比较灵活，各种不同的属性只要淸足以下结构即可

* 即**只需说明属性的名称以及占用位数的长度即可**，属性表具体的结构可以去自定义。

| 类型 | 名称                 | 数量             | 含义       |
| ---- | -------------------- | ---------------- | ---------- |
| u2   | attribute_name_index | 1                | 属性名索引 |
| u4   | attribute_length     | 1                | 属性长度   |
| u1   | info                 | attribute_length | 属性表     |



属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性，下面这些是虚拟机中预定义的属性





## 5、javap 指令解析

可选参数

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-25_16-27-29.png)





# 二、字节码指令集

## 1、概述

**Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码， Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数 Operands）而构成**。由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作

由于限制了 **Java** 虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的**操作码总数不可能超过 256 条** 

熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令



### 1.1 执行模型

```java
do{
白动计算 PC 寄存器的值加 1；
根据 PC 寄存器的指示位置，从字节码流中取出操作码
if（字节码存在操作数）从字节码流中取出操作数
执行操作码所定义的操作
}whie（字节码长度>）；
```



### 1.2 字节码与数据类型

在 Java 虚拟机的指令集中，**大多数的指令都包含了其操作所对应的数据类型信息**。例如，iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据

也有一些指令的助记符中**没有明确地指明操作类型的字母**，如  arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象

还有另外一些指令，如无条件跳转指令 **goto**。则是与数据类型无关的

大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean类型。**编译器会在编译期或运期将 byte和 short 类型的数据带符号扩展（Sign- Extend）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（zero- Extend）为相应的 int 类型数据** 

与之类似，在处理 boolean、byte、 short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、 short 和 char 类型数据的操作实际上都是使用相应的 int 类型作为运算类型

## 2、加载与存储指令

* 作用

加载和存储指令用于**将数据从栈帧的局部变量表和操作数栈之间来回传递** 



### 常用指令

> 局部变量压栈指令

* 将一个**局部变量**加载到作数栈：`xload、xload_<n>`，x 为数据类型
    * x 为 i、l、f、d、a
    * n 为 0~3 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-26_09-07-52.png)



> 常量入栈指令

* 将一个**常量**加载到操作数栈

```
bipush、 sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_ml、 iconst_<i>、 lconst_<i>、 fconst_<f>、 dconst_<d>
```

**==const 指令系列==**：用于对**特定的**常量入栈，入栈的常量隐含在指令本身里。指令有：`iconst_<i>`（i从 -1 到 5）、  `lconst_<l>`（l 从 0 到 1）、 `fconst_<f>`（ f 从 0 到 2）、 `dconst_<d>`（ d 从 0 到 1）、 `aconst_null` 

**==push 指令系列==**：主要包括 **bipush 和 sipush。它们的区别在于接收数据类型的不同**， bipush 接收 8 位整数[-128~127] 作为参数，sipush 接收 16 位整数 [ -32768，32767 ]，它们都将参数压入栈

**==ldc 指令系列==**：如果以上指令都不能满足需求，那么可以使用**万能的 ldc 指令**，它可以接收一个 8 位的参数，该参数指向常量池中的 **int、float** 或者 **String** 的索引，将指定的内容压入堆栈

* 类似的还有 `ldc_w`，它接收两个 8 位参数，能支持的索引范围大于 `ldc` 
* 如果要压入的元素是 `long` 或者 `double` 类型的，则使用 `ldc2_w` 指令，使用方式都是类似的



> 出栈装入局部变量表指令

* 用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量斌值
    * `xstore_<n>`（其中 x 为 i、l、f、d、an为 0 ~ 3）
        * `istore_<n>` 将从操作数栈中弹出一个整数，并把它赋值给局部变量==**索引 n 位置**== 
    * `xastore`（其中 x 为 i、l、f、d、a）
        * 指令 `xastore` 由于没有隐含参数信息，故**需要提供一个 byte 类型参数**指定目标局部变量表的位置



> 扩充局部变量表的访问索引的指令：**wide** 



上面所列举的指令助记有一部分是以尖括号结尾的（例如 `load_<n>`）：这些指令助记符实际上代表了一组指令，这组指令都是某个带有一个操作数的通用指令（例如 `iload`）的特殊形式，**对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中** 

除此之外，它们的语义与原生的通用指令完全一致（例如 `iload_0`的语义与操作数为 0 时的 iload 指令语义完全一致）。**在尖括号之间的字母指定了指令隐含操作数的数据类型**，`<n>` 代表非负的整数，`<i>` 代表是 int 类型数据，`<l>`代表 long 类型，`<f>`代表 float 类型，`<d>` 代表  double 类型



## 3、算数指令

大体上算术指令可以分为两种：对**整型数据**进行运算的指令与对**浮点类型数据**进行运算的指令

算术指令用于对操作数栈上的两个值进行某种特定运算，**把结果重新压入操作数栈** 



**没有直接支持 byte, short、char、boolean 类型的算术指令，对于这些数据的运算，都使用 ==int 类型==的指令来处理**。此外，在**处理 bolean、byte、short、char 类型的数组**时，也会转换为使用对应的 int 类型的字节码指令来处理

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-26_10-33-56.png)



> 数据溢出

数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虛拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为 0 时会导致虚拟机抛出异常 **ArithmeticException** 



> 运算模式

**==最接近数舍入模式==**：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，**将优先选择最低有效位为零的** 

**==向零舍入模式==**：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果



> NaN

一个操作产生溢出时，将会使用有符号的无穷大表示，**如果某个操作结果没有明确的数学定义的话，将会使用 NaN值来表示**。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN



> 具体指令

|   加法指令   |        iadd、ladd、fadd、dadd        |
| :----------: | :----------------------------------: |
|   减法指令   |        isub、lsub、fsub、dsub        |
|   乘法指令   |        imul、lmul、fmul、dmul        |
|   除法指令   |        idiv、ldiv、fdiv、ddiv        |
|   求余指令   |        irem、lrem、frem、drem        |
|   取反指令   |        ineg、lneg、fneg、dneg        |
|   自增指令   |                 iinc                 |
|              |                                      |
|   位移指令   | ishl、ishr、iushr、lshl、lshr、lushr |
|  按位或指令  |               ior、lor               |
|  按位与指令  |              iand、land              |
| 按位异或指令 |              ixor、lxor              |
|              |                                      |
|   比较指令   |   dcmpg、dcmpl、fcmpg、fcmpl、lcmp   |

> 比较指令说明

* 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈
    * 与前面讲解的指令类似，**首字符 d 表示 double 类型，f 表示 float ，l 表示 long** 
* 对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令
    * **以 float 为例，有 fcmpg 和 fcmpl 两个指令**，它们的区别在于在数字比较时，**若遇到 NaN 值，处理结果不同** 
        * 两个指令的不同之处在于，**如果遇到 NaN 值， fcmpg 会压入 1，而 fcmpl 会压入 -1** 
* 指令 **dcmpg** 和 **dampl** 也是类似的，根据其命名可以推测其含义
* 指令 **lcmp** 针对 **long** 型整数，**由于 long 型整数没有 NaN 值，故无需准备两套指令** 



举例：

指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2，栈顶顺位第 2 位的元素为 v1

* 若 v1=V2，则压入 0
* 若 v1>V2 则压入 1
* 若 v1<v2 则压入 -1



## 4、类型转换指令

> 说明

类型转换指令可以将**两种不同的数值类型**进行相互转换

这些转换操作一般用于实现用户代码中的**显式类型转换操作**，或者用来处理**字节码指令集中数据类型相关指令无法与数据类型一一对应的问题** 





### 宽化类型转换

> 转换规则

Java 虚拟机直接支持以下数值的宽化类型转换（小范围类型向大范围类型的安全转换），也就是说，并不雷要指令执行，包括：

* 从 int 类型到 long、float、double 类型。对应的令为：i2l、i2f、i2d
* 从 long 类型到 float、double 类型。对应的指令为：l2f、l2d
* 从 float 类型到 double 类型。对应的指令为：f2d

**==简化为：int-->long--> float-->double==** 



> 精度损失问题

尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常

宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的



**从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生精度丢失**——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数值



> 关于 **byte、short、char** 的转换

**从 byte、char、short 类型到 int 型的宽化类型转换实际上是不存在的**：对于 **byte 类型转为 int**，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 **byte 转为 long 时，使用的是 i2l**。可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点

* 一方面可以减少实际的数据类型，**如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过 256 个**，为了节省指令资源，将 short 和 byte 当做 int 处埋也在情理之中
* 另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间，从这个角度说，也没有必要特意区分这几种数据类型



### 窄化类型转换

> 转化规则

Java 虚拟机也直接支持以下窄化类型转换：

* 从 int 类型到 byte、 short、char 类型。对应的指令有：**i2b、i2s、i2c** 
* 从 long 类型到 int 类型。对应的指令有：**l2i** 
* 从 float 类型到 int 或者 long 类型，对应的指令有：**f2i、f2l** 
* 从 double 类型到 int、long、float 类型。对应的指令有：**d2i、d2l、d2f** 



> 精度损失问题

窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度

尽管数据类型窄化转换可能会发生上限溢出、下限溢岀和精度丢失等情况，但是 **Java 虚拟札规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机拋出运行时异常** 



> 补充说明

当将一个**浮点值**窄化转换为整数类型T（T限于 int 或 long 类型之一）的时候，将遵循以下转换规则

* 如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0
* 如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数



当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则，通过向最接近数舍入模式舍入一个可以使用float 类型表示的数字。最后结果根据下面这 3 条规则判断

* 如果转换结果的**绝对值太==小==**而无法使用 float 来表示，将返回 float 类型的正负零
* 如果转换结果的**绝对值太==大==**而无法使用 float 来表示，将返回 float 类型的正负无穷大
* 对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值





## 5、类的创建与访问指令

Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。**有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令** 



### 创建指令

虽然类实例和数组都是对象，**但 Java 虚拟机对==类实例==和==数组==的创建与操作使用了==不同的字节码指令==** 



#### 类创建指令

创建类实例的指令：new

* 它接收一个操作数，**为指向常量池的索引，表示要创建的类型**，执行完成后，将对象的引用压入栈



#### 数组创建指令

创建数组的指令：

* **newarray**：创建基本类型数组
* **anewarray**：创建引用类型数组
* **multianewarray**：创建多维数组





### 字段访问指令

对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素

* 访问类字段（ static字段，或者称为类变量）的指令：**getstatic、 putstatic** 
* 访问类实例字段（非 static 字段，或者称为实例变量）的指令：**getfield、 putfield** 





### 数组操作指令

数组操作指令主要有：**xastore 和 xaload 指令** 

* 把一个数组元素**加载到操作数栈**的指令
    * baload、 caload、 saload、 ialad、laload、faload、daload、aaload 
* 将一个操作数栈的值**存储到数组元素中**的指令
    * bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore 
    * 此处并不是存储到局部变量表中，而是存储到堆空间的数组

> 加载： -load   存储：-store

|   数组类型    | 加载指令 | 存储指令 |
| :-----------: | :------: | :------: |
| byte、boolean |  baload  | bastore  |
|     char      |  caload  | castore  |
|     short     |  saload  | sastore  |
|      int      |  iaload  | iastore  |
|     long      |  laload  | lastore  |
|     float     |  faload  | fastore  |
|    double     |  daload  | dastore  |
|   reference   |  aaload  | aastore  |

**==说明：==** 

指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。**指令 xaload 在执行时，要求操作数中==栈顶元素为数组引用 a==，==栈顶顺位第2个元素为数组索引 i数组引用 a==，该指令会弹出栈顶这两个元素，并将 a[ i ]重新压入堆栈** 

**xastore** 则专门针对数组操作，以 **iastore** 为例，它用于给一个 **int 数组**的给定索引赋值。在 **iastore** 执行前，操作数栈顶需要以此**准备 3 个元素：数组引用（栈顶）、数组元素索引（栈顶顺位第二个）、值（栈顶顺位第三个）**， **iastore** 会弹出这 3 个值，并将值赋给数组中指定索引位置

**==获取数组长度指令：arraylength==** 

* 该指令**弹出栈顶的数组元素，获取数组的长度，将长度压入栈** 



### 类型检查指令

检查**类实例**或**数组类型**的指令：**instanceof、 checkcast** 

指令 **checkcast** 用于**检查类型强制转换是否可以进行**。如果可以进行，那么 **checkcast** 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常

指令 instanceof 用来**判断给定对象是否是某一个类的实例**，它会**将判断结果（boolean 类型）压入操作数栈** 





## 6、方法调用与返回指令



### 方法调用指令

方法调用指令：**invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic** 

**==invokevirtual 指令==**：用于调用对象的**实例方法**，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是 Java语言中最常见的方法分派方式

**==invokeinterface 指令==**：用于调用**接口方法**，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用

**==invokespecial 指令==**：用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和类方法。这些方法都是**静态类型绑定**的，不在调用时进行动态派发

**==invokestatic 指令==**：用于调用命名类中的**类方法（ static方法）**，这是**静态绑定**的

**==invokedynamic 指令==**：调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻是由用户所设定的引导方法决定的



### 方法返回指令

方法返叫指令是根据**返回值的类型**区分的

* 包括 ireturn（当返回值是 boolean、byte、char、 short 和 int 类型时使用）、lreturn、freturn、dreturn、areturn
* 另外还有一条 **return 指令**供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用

举例：

通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素**压入==调用者==函数的操作数栈中**（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃

如果当前返回的是 **synchronized 方法**，那么还会执行一个**隐含的 monitorexit 指令**，退出临界区

最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者





## 7、操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于**直接操作操作数栈的指令**，这类指令包括如下内容：

* 将一个或两个元索从栈顶弹出，并且直接废齐：**pop、pop2** 
    * 弹出的是 Slot，一个 Slot 四个字节，若要弹出一个 long 型数据，则需要使用 pop2 弹出两个 Slot
* 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶
    * **dup、dup2、dup_x1、dup2×1、dup_x2、dup2_x2** 
* 将栈中最顶端的两个 slot 数值位置交换：swap
    * Java 虚拟机没有提供交换两个64位数据类型（ long、double）数值的指令
* **指令 nop** 是一个非常特殊的指令，它的字节码为 0x00，和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等

这些指令属于通用型，对栈的压入或者弹出无需指明数据类型



说明：

不带 `_x` 的指令是复制栈顶数据并压入栈顶。包括两个指令，dup、dup2，dup的系数代表要复制的 Slot 个数

带 `_x` 的指令是复制栈顶数据并插入栈顶以下的某个位置。其有4个指令，如 `dup_x1，dup2_×1，dup_x2，dup2_x2`，对于带 `_x` 的复制插入指令，**==只要将指令的 dup 和 x 的系数相加，结果即为清要插入的位置==**。因此

* dup_×1 插入位置：1+1=2，即栈顶 2 个 Slot 下面
* dup_×2 插入位置：1+2=3，即栈顶 3 个 Slot 下面
* dup2_x1插入位置：2+1=3，即栈顶 3 个 Slot 下面
* dup2_×2 插入位置：2+2=4，即栈顶 4 个 Slot 下面





## 8、控制转移指令



### 条件跳转指令

条件跳转抬令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转

条件跳转指令有：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull，这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的 offset）

它们的统一含义为：弹出栈顶元素，测试它是否满是某一条件，如果满是条件，则跳转到给定位置

|   ifeq    | 当栈顶 int 类型数值等于 0 时跳转     |
| :-------: | ------------------------------------ |
|   ifne    | 当栈顶 int 类型数值不等于 0 时跳转   |
|           |                                      |
|   iflt    | 当栈顶 int 类型数值小于 0 时跳转     |
|   ifle    | 当栈顶 int 类型数值小于等于 0 时跳转 |
|           |                                      |
|   ifgt    | 当栈顶 int 类型数值大于 0 时跳转     |
|   ifge    | 当栈顶 int 类型数值大于等于 0 时跳转 |
|           |                                      |
|  ifnull   | 为 null 时跳转                       |
| ifnonnull | 不为 null 时跳转                     |

运算法则

* 对于 boolean、byte、char、 short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成
* 对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转

由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大



### 比较、条件跳转指令

比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一

* **栈顶元素为后者（v2），顺位第二个元素为前者（v1）** 

|   指令    | 含义                                             |
| :-------: | ------------------------------------------------ |
| if_icmpeq | 比较栈顶两个 int 类型数值大小，v1=v2 时跳转      |
| if_icmpne | 比较栈顶两个 int 类型数值大小，v1 != v2 时跳转   |
|           |                                                  |
| if_icmplt | 比较栈顶两个 int 类型数值大小，v1 < v2 时跳转    |
| if_icmple | 比较栈顶两个 int 类型数值大小，v1 <= v2时跳转    |
|           |                                                  |
| if_icmpgt | 比较栈顶两个 int 类型数值大小，v1 > v2时跳转     |
| if_icmpge | 比较栈顶两个 int 类型数值大小，v1 >= v2时跳转    |
|           |                                                  |
| if_acmpeq | 比较栈顶两个**==引用类型==**数值，v1 = v2时跳转  |
| if_acmpne | 比较栈顶两个**==引用类型==**数值，v1 != v2时跳转 |



这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元索，进行比较指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。**如果预设条件成立，则执行跳转，否则，继续执行下条语句** 





### 多条件分支跳转

多条件分支跳转指令是**专为 switch-case 语句设计**的，主要有 **tableswitch 和 lookupswitch** 

|    指令     |                作用                 |
| :---------: | :---------------------------------: |
| tableswitch |  用于 switch 条件跳转，case 值连续  |
| ookupswitch | 用于 switch 条件跳转，case 值不连续 |

**tableswitch 要求多个条件分支值是连续的**，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高

指令 lookupswitch 内部存放着各个离散的 case-offset 对，**每次执行都要搜索全部的 case-offset 对**，找到匹配的case 值，并根据对应的 offset 计算跳转地址，因此效率较低



### 无条件跳转

目前主要的无条件跳转指令为 **goto**。指令 **goto** 接收两个字节的操作数，共同组成一个带符号的整数，**用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处** 

如果指令偏移量太大，超过两个字节的带符号整数的范围，则可以使用指令 **goto_w**，它和 **goto** 有相同的作用，但是它接收 4 个字节的操作数，可以表示更大的地址范围

指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且**已经被虚拟机逐渐废弃**，故不在这里介绍这两个指令

| 指令名称 |                             作用                             |
| :------: | :----------------------------------------------------------: |
|   goto   |                          无条件跳转                          |
|  goto_w  |                     无条件跳转（宽范围）                     |
|   jsr    | 跳转至指定 16 位 offset 位置，并将 jsr 下一条指令地址压入找顶 |
|  jsr_w   | 跳转至指定 32 位 offset 位置，并将 jsr 下一条指令地址压入找顶 |
|   ret    | 返回至指定的局部变量所给出的指令位置（一般与 jsr、jsr_w 联合使用） |



## 9、异常处理指令



### 异常抛出指令

在 Java 程序中显示抛出异常的操作（ throw 语句）都是由 **athrow 指令**来实现

除了使用 throw 语句显示抛出异常情况之外，**JVM 规范还规定了许多运行时异常会在其他 Java 虛拟机指令检测到异常状况时自动抛出**。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException 异常

正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是**在抛异常时，Java 虚拟机会清除操作数栈的所有内容，而后将异常实例压入调用者操作数栈上** 



### 异常处理与异常表

> 异常处理

在 Java 虚拟机中，处理异常（ catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret指令），而是用**异常表**来完成



> 异常表

如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表，它包含了每个异常处理或者finally 块的信息。异常表保存了每个异常处理信息。比如

* 起始位置
* 结束位置
* 程序计数器记录的处理代码的偏移地址
* 被捕获的异常在常量池中的索引



**当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法**（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止

如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程



**不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行**。在这种情况下，如果方法结束后没有池出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标





## 10、同步控制指令

Java 虚拟机支持两种同步结构：**方法级的同步和方法内部段指令序列的同步**，这两种同步都是使用 **monitor** 来支持的



### 方法级同步

**方法级的同步是==隐式的==，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中**，虚拟机可以从方法常量池的方法表结构中的 **ACC_SYNCHRONIZED 访问标志**得知一个方法是否声明为同步方法



当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置

* 如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
* 在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁
* 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放





### 代码块级同步

同步一段指令集序列，通常是由 Java 中的 synchronized语句块来表示的。JVM 的指令集有 **monitorenter** 和**monitorexit** 两条指令来支持 synchronized 关键字的语义

当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。**如果当前==对象的监视器计数器==为 0，则它会被准许进入，若为 1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待**，直到对象的监视器计数器为 0，才会被允许进入同步块

当线程退出同步块时，需要使用 monitorexit 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对处于锁定状态

指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的





# 三、类加载过程(声明周期)详解

## 1、概述

在 Java 中数据类型分为基本数据类型和引用数据类型。**基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载** 

按照 Java 虛拟机规范，从 Class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命冏期包括如下 7 个阶段

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-27_12-43-22.png)



**验证、准备、解析 3 个部分统称为链接（ Linking）** 





## 2、Loading（加载）阶段



### 加载完成的操作

> 加载的理解

所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 **Java 类的原型一一类模板对象** 

**所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照**，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样 JVM 在运行期便能通过类模板获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用

反射的机制正是基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射



> 加载完成的操作

加载阶段，简言之，查找并加载类的二进制数据，**生成 Class 的实例** 

在加载类时，Java 虚拟机必须完成以下 3 件事情：

1、通过类的全名，获取类的二进制数据流

2、解析类的二进制数据流并生成方法区内的数据结构（Java 类模型）

3、**创建 java.lang.Class 类的实例**，表示该类型。作为方法区中这个类的各种数据的访问入口



### 二进制流获取方式

对于类的二进制数据流，虛拟机可以通过多种途径产生或获得（只要所读取的字节码符合 JVM 规范即可）

1、虚拟机可能通过文件系统读入一个 .class 后缀的文件（最常见）

2、读入 jar、zip 等归档数据包，提取类文件

3、事先存放在数据库中的类的二进制数据

4、使用类似于 HTTP 之类的协议通过网络进行加载

5、在运行时生成一段 class 的二进制信息

在获取到类的二选制信息后，Java 虛拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError 异常





### 类模型与 Class 实例位置

> 类模型位置

加载的类在 JVM 中创建相应的类结构，类结构会储在方法区（JDK 1.8之前：永久代，JDK 1.8 及之后：元空间）



> Class 实例位置

将 **.class** 文件加载至元空间后，会在堆中创建一个 **java.lang.Class** 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，**每个类都对应有一个 Class 类型的对象** 



> 说明

Class 类的构造方法是私有的，只有 JVM 能够创建

java.lang.Class 实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过 Class 类提供的接口，可以获得目标类所关联的 .class 文件中具体的数据结构：方法、字段等信息





### 数组类的加载

创建数组类的情况稍有些特姝，因为**数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建**的，但**数组的==元素类型==仍然需要依靠类加载器去创建**。创建数组类（下述简称A）的过程：

1、如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型

2、JVM 使用指定的元素类型和数组维度来创建新的数组类



如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定，否则数组类的可访问性将被缺省定义为 public



## 3、Linking（链接）阶段



### 验证阶段（Verification）

它的目的是保让加载的字节码是合法、合理并且符合规范的

验证的步骤比较复杂，实际要验证的项日也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-27_13-23-56.png)

验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等

* 其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中
* 格式验证之外的验证操作将会在方法区中进行

链接阶段的验证虽然拖慢了加载速度，但是它免了在字节码在运行时还要进行各种检查（磨刀不误砍柴功）



**==格式验证==**：是否以魔数 OXCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等

**==语义检查==**：但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如

1、是否所有的类都有父类的存在（在 Java 里，除了 Object 外，其他类都应该有父类）

2、是否一些被定义为 final 的方法或者类被重写或继承了

3、非抽象类是否实现了所有抽象方法或者接口方法

4、是否存在不兼容的方法

* 比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度
* abstract 情况下的方法，就不能是 final 的了

**==字节码验证==**：字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确执行，比如

1、在字节码的执行过程中，是否会跳转到一条不存在的指令

2、函数的调用是否传递了正确类型的参数

3、变量的赋值是不是给了正确的数据类型等

栈映射帧（ StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型

但遗憾的是，**==100% 确地判断一段字节码是否可以被安全执行是无法实现的==**，因此，该过程只是尽可能地检查出可以预知的明显的问题

如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，**如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的** 

**==符引用验正==**：Class 文件会在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，**虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据** 

如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError，**此阶段在解析环节才会执行** 



### 准备（Preparation）阶段

> 作用

为类的**静态变量**分配内存，并**将其初始化为默认值** 

当一个类验证通过时，Java 虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存室间，并设置默认初始值



> 注意

1、这里不包含基本数据类型的字段用 static final 修饰的情况，**因为 final 在==编译时==就会分配了**，准备阶段会显式赋值

2、注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中

3、在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行





### 解析（Resolution）阶段

> 作用

将类、接口、字段、方法的符号引用转为直接引用

符号引用就是一些字面量的引用，跟虚拟机的内部数据结构和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用

但是在程序实际运行时，只有符号引用是不够的。比如当如下  println() 方法被调用时，系统需要明确知道该方法的位置

以方法为例，Java 虚拟机为每个类都淮备了一张方法表，所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。**通过解析操作，符号引用就可以转变为目标方法在类 方法表中的位置，从而使得方法被成功调用** 



> 小结

所谓解析就是将符号引用转为直接用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。**但只存在符号引用，不能确定系统中一定存在该结构** 

不过 Java 虛拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不地执行，但链接阶段中的解析操作往往会件随着 JVM 在执行完初始化之后再执行



## 4、初始化（Initialization）阶段

> 作用

为类的静态变量赋予正确的**初始值** 



> 具体描述

类的初始化是类装载的最后一个阶段，前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行 Java 字节码（**即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码**）



初始化阶段的重要工作是执行类的初始化方法：`<clinit>() ` 方法

1、该方法仅能由 Java 编译器生成并由 JVM 调用，程序开发者无法自定义一个同名的方法，更无法直接在 Java 程序中调用该方法，虽然该方法也是由字节码指令所组成

2、它是**由类静态成员的赋值语句以及 static 语句块合并产生的** 



在加载一个类之前，虚拟机总是会试图加载该类的父类，因此**父类的 <c1init> 总是在子类 <c1init> 之前被调用也就是说，父类的 static 块优先级高于子类** 



Java 编译器并不会为所有的类都产生 <c1init> 初始化方法。**以下情况类在编译为字节码后，字节码文件中将不会包含<c1init>（）方法** 

1、一个类中并没有声明任何的类变量，也没有静态代码块

2、一个类中声明类变量，但是**没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作** 

3、一个类中**包含 static final 修饰的基本数据类型的字段**，这些类字段初始化语句采用编译时常量表达式



### 准备阶段和初始化阶段的赋值比较

```java
public class InitializationTest2 {public static int a = 1;   // 在初始化阶段<clinit>()中赋值public static final int INT_CONSTANT = 10; // 在链接阶段的准备环节赋值public static final Integer INTEGER_1 = Integer.valueOf(100); // 在初始化阶段<clinit>()中赋值public static Integer INTEGER_2 = Integer.valueOf(1000);  // 在初始化阶段<clinit>()中赋值public static String s2 = "cccc";   // 在初始化阶段<clinit>()中赋值public static final String s0 = "aaaaa";// 在链接阶段的准备环节赋值public static final String s1 = new String("bbbb"); // 在初始化阶段<clinit>()中赋值public static final int NUM1 = new Random().nextInt(10); // 在初始化阶段<clinit>()中赋值}
```

在**==链接阶段的准备环节==**赋值的情况：

1、对于基本数据类型（不包括包装类）的字段来说，如果**使用 static final 修饰**，则显式赋值（**直接赋值常量**，而非调用方法）通常是在链接阶段的准备环节进行

2、对于 String 来说，如果**使用字面量的方式赋值，使用 static final 修饰**的话，则显式赋值通常是在链接阶段的准备环节进行

在**初始化阶段<clinit>()中**赋值的情况：

排除上述的在准备环节赋值的情况之外的情况

> 最终结论

**==使用 static + final 修饰==**，且显示赋值中**==不涉及到方法或构造器调用==**的**==基本数据类型（不包含包装类）==**或 **==String 类型==**的**==显式赋值==**，是在链接阶段的准备环节进行



> <clinit> 的线程安全情况

虚拟机会保证一个类的 <c1init>（）方法在多线程坏境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那只会有一个线程去执行这个类的 <c1init>（） 方法，其他线程都需要阻塞等待，直到活动线程执行<c1init>（）方法完毕

正是因为函数 <c1nit>（）带锁线程安全的，因此，如果在一个类的 <clinit>（）方法中有耗时很长的操作，就可能造成多线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息

如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <c1init>（）方法了。那么，当需要使用这个类时虚拟机会直接返回给它已经准备好的信息





### 类的主动使用和被动使用

> 主动使用

**Class 只有在首次使用的时候才会被装载**，Java 虚拟机不会无条件地装载 Class 类型。**Java 虛拟机规定，一个==类或接口==在初次使用前，必须要进行初始化**。这里指的 "使用" 是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）

1、创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化

2、调用类的静态方法时，即当使用了字节码 invokestatic 指令

3、使用类、接口的静态字段时（ final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令

4、使用 java.lang.reflect 包中的方法反射类的方法。比如：Class.forName("com.atguigu.java.Test")

5、初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化

* 这条规则并不适用于接口，在初始化一个类时，并不会先初始化它所实现的接口，在初始化一个接冂时，并不会先初始化它的父接口
* 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序**首次使用特定接口的静态字段**时，才会导致该接口的初始化

6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，**该接口要在其之前被初始化** 

7、虚拟机启动时，用户需要指定一个要执行的主类（包含main () 方法的那个类），虚拟机会先初始化这个主类

* JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main（ String[] ）方法之前被链接和初始化。**这个方法的执行将依次导致所需的类的加载，链接和初始化** 

8、初次调用 **MethodHandle 实例**时，初始化该 MethodHandle 指向的方法所在的类



> 被动使用

**除了以上的情况属于主动使用，其他的情况均属于被动使用**。被动使用不会引起类的初始化，也就是说，并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化

1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化

* 当通过子类引用父类的静态变量，不会导致子类初始化

2、通过数组定义类引用，不会触发此类的初始化

3、引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了

4、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化





## 5、类的使用（Using）

任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一且一个类型成功经历过这 3个步骤后，便 "万事俱备，只欠东风"，就等着开发者使用了。

开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例



## 6、类的卸载（Unloading）



### 类、类加载器、类实例

在类加载器的内部实现中，用一个 **Java** 集合来存放所加载类的引用。另一方面，一个 **Class** 对象总是会引用它的类加载器。调用 **Class** 对象的 **getClassLoader()** 方法，就能获得它的类加载器

由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系



一个类的实例总是引用代表这个类的 **Class** 对象。在 **Object** 类中定义了 **getClass()** 方法，这个方法返回代表对象所属类的 **Class** 对象的引用。此外，所有的 **Java** 类都有一个静态属性 **Class**，它引用代表这个类的 **Class** 对象



### 类的声明周期

当 Sample 类被加载、链接、初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命同期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-28_11-28-25.png)

loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它

如果程序运行过程中，将上左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Samle 类的 Class 对象也结束生命周期， Sample 类在方法区内的二进制数据被卸载

当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载。如果不存在Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 例（可通过哈希码查看是否是同一个实例）



### 类的卸载

1、**启动类加载器**加载的类型在整个运行期间是不可能被卸载的（ JVM 和 JLS 规范）

2、**系统类加载器和扩展类加载器**加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能被直接或者间接的访问的到，其达到 unreachable 的可能性极小

3、被开发者自定义的类加载器实例加载的类型**只有在很简单的上下文坏境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到**。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）

综合以上三点，一个已经加载的类型被卸载的几率很小，至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虛拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能



# 四、类加载器

## 1、概述

类加载器是 JVM 执行类加载机制的前提

> ClassLoader 的作用

**ClassLoader 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的**，ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang.Class 对象实例，然后交给 Java 虚拟机进行链接、初始化等操作

因此，**ClassLoader 在整个装载阶段，只能影响到类的加载**，而无法通过 ClassLoader 去改变类的链接和初始化行为。**至于它是否可以运行，则由 ExecutionEngine 决定** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-28_19-36-24.png)





### 类的加载分类

> 显示加载、隐式加载

Class 文件的显式加载与隐式加载的方式是指 JVM 加载 Class 文件到内存的方式

**==显式加载==**：在代码中通过调用 ClassLoader 加载Class 对象，如直接使用 Class.forName(name) 或this. getClass().getClassLoader().loadClass() 加载 class 对象

**==隐式加载==**：不直接在代码中调用 ClassLoader 的方法加载 Class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 class文件时，该类的 class 文件中引用了另外一个类的对象，此时**额外引用的类将通过 JVM 自动加载到内存中** 



### 命名空间

**对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在 Java 拟机中的唯一性**。每一个类加载器，都拥有一个独立的类名称空间

**比较两个类是否相等，只有在这两个类是==由同一个类加载器加载==的前提下才有意义**。否则即使这两个类源自同一个Class 文件，被同一个虚拟机加载，**只要加载他们的类加载器不同，那这两个类就必定不相等** 

> 命名空间

1、每个类加载器都有自己的命名空间，**命名空间由该加载器及所有的父加载器==所加载的类==组成** 

2、在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类

3、在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本



### 类加载机制特征

**==双亲委派模型==**：但不是所有类加载部遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider / ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供一些默认的参考实现。例如，Java 中 NDI、JDBC、文件系统、 Cipher 等很多方面，都是利用的这种制，这**种情况就不会用双亲交派模型去加载，而是利用所谓的上下文加载器** 

**==可见性==**：子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻缉

**==单一性==**：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载，但是注意，**在不同的类加载器中，同一类型仍然可以被加载多次，因为互相并不可见** 



## 2、类加载器的分类

JVM 支持两种类型的类加载器，分别为**引导( 启动 )类加载器（ Bootstrap  ClassLoader）和自定义类加载器** 

从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规却没有这么定义，**JVM 规范将所有==派生于抽象类 ClassLoader== 的类加载器都划分为==自定义类加载器==**。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-28_20-36-44.png)

除了顶层的启动类加载器外，其余的类加载器都应当有自己的 “父类” 加载器

不同类加载器看似是继承关系，实际上是包含关系。**在下层加载器中，包含着上层加载器的引用** 



### 启动类加载器（Bootstrap）

1、这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部，它**用来加载 Java 的核心库**（ JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容）。用于提供 JVM 自身需要的类

2、并不继承自 java.lang.ClassLoader，没有父加载器

3、**出于安全考虑， Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类** 

4、加载扩展类和应用程序类加载器，并指定为他们的父类加载器



### 扩展类加载器（Extension）

1、Java 语言编写，由  sun.misc.Launcher$ExtClassLoader 实现

2、继承于 ClassLoader 类，父类加载器为启动类加载器

3、从 **java.ext.dirs** 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 **jre/lib/ext** 子目录下加载类库。如果用户创建的 jar 放在此目录下，也会自动由扩展类加载器加载



### 应用程序类加载器（application）

1、Java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现

2、继承于 ClassLoader 类，父类加载器为括展类加载器

3、它负责加载环境交量 classpath 或系统属性 java.class.path 指定路径下的类库

4、应用程序中的类加载器默认是系统类加载器，它是用户自定义类加载器的默认父加载器

5、通过 ClassLoader 的 getSystemClassLoader() 方法可以获取到该类加载器



### 用户自定义类加载器

1、在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式

2、体现 Java 语言强大生命力和巨大魅力的关键因素之一便是 Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 jar 包，也可以是网络上的远程资源

3、**通过类加载器可以实现非常绝妙的插件机制**，这方面的实际应用案例举不胜举。例如，善名的 0SGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现

4、**自定义类加载器能够实现应用隔离**，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多，**想不修改 C/C+ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想** 

5、自定义类加载器通常需要承于 ClassLoader



## 3、测试不同的类加载器

> 获取 ClassLoader 途径

获取当前类的 ClassLoader：**clazz.getClassLoader()** 

获取当前线程上下文的 ClassLoader：**Thread.currentThread().getContextClassLoader()** 

获取系统类加载器：**ClassLoader.getSystemClassLoader()** 

站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C/C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写而成的。**由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值** 



> 关于数组

数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期间 JVM 根据需要自动创建的。对于数组类的类加器来说，是**通过 Class.getClassLoader() 返回**的，**==与数组当中元素类型的类加载器是一样的==**；如果数组当中的元素类型基本数据类型时，是没有类加载器，因为基本数据类型是 JVM 预先自定义的，不需要加载



## 4、ClassLoader 源码解析

> ClassLoader 与现有类加载器的关系

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-29_08-46-33.png)

除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。**Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类** 



### ClassLoader 的主要方法

> **public final ClassLoader getParent()** 

返回该类的父加载器



> **public Class<?>  loadClass（String name）throws ClassNotFoundException** 

加载名称为 name 的类，返回结果为 java.lang.Class 类的实例。如果找不到类，则返回 ClassNotFoundException异常。**==该方法中的逻辑就是双亲委派模式的实现==** 

```java
// 加载测试代码
ClassLoader.getSystemClassLoader.loadClass("com.tfc.java.User")；

// resolve 为 true 表示加载的时候进行解析，源码中为 false
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
synchronized (getClassLoadingLock(name)) {  // 同步操作，只能加载一次
// 首先检查是否已经加载过同名的类
Class<?> c = findLoadedClass(name);
if (c == null) {
long t0 = System.nanoTime();
try {
// 获取当前类加载器的父加载器
if (parent != null) {
// 双亲委派机制：如果存在父加载器，则调用父加载器进行加载
c = parent.loadClass(name, false);
} else { // parent 为 null，父加载器是引导类加载器
c = findBootstrapClassOrNull(name);
}
} catch (ClassNotFoundException e) {
// ClassNotFoundException thrown if class not found
// from the non-null parent class loader
}

// 当前类的父加载器未加载此类 or 当前类加载器未加载此类
if (c == null) {
// If still not found, then invoke findClass in order
// to find the class.
long t1 = System.nanoTime();
// 调用当前 ClassLoader 的 findClass() 
c = findClass(name);

// this is the defining class loader; record the stats
sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
sun.misc.PerfCounter.getFindClasses().increment();
}
}
if (resolve) {   // 是否进行解析
resolveClass(c);
}
return c;
}
}
```



> **protected Class<?> findClass（String name）throws ClassNotFoundException** 

查找二进制名称为 name 的类，返回结果为 java.lang.Class 类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，自定义加载器需要遵循双亲委托机制，**该方法会在检查完父类加载器之后被 loadClass（）方法调用** 

在 JDK 1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写方法，从而实现自定义的类加载类。但是**在 JDK 1.2 之后已不建议用户去覆盖 ==loadClass（）==方法，而是建议把自定义的类加载==逻辑写在 findClass（）==方法中** 

从前面的分析可知，==**findClass（）方法是在 loadClass（）方法中被调用的**==，当 loadClass（）方法中父加载器加载失败后，则会调用自己的 findClass（）方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式

需要注意的是 **ClassLoader类中并没有实现 findClass（）方法的具体代码逻辑，而是==被子类(URLClassLoader)重写==**，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 **findClass（）方法通常是和 defineClass（）方法一起使用的** 

一般况下，**在自定义类加载器直接覆盖 ClassLoader 的 findClass（）方法并编写加载规则，取得要加载类的节码后转换成流，==然后调用 defineClass（）方法生成类的 Class 对象==** 



> **protected final Class<?> defineClass（String name，byte[] b，int off，int len）** 

**根据给定的字节数组 b 转换为 Class 的实例**，off 和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 ClassLoader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用

**defineClass（）方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中己实现该方法逻辑）**，通过这个方法不仅能够通过 class 文件实例化 Class 对象，也可以通过其他方式例化 Class 对象，如通过网络接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象

**defineClass（）方法通常与 findClass（）法一起使用**，一般情况下，**==在自定义类加载器时，会直接覆盖Classloader的 findClass（）方法并编写加载规则，取得要加载的类的字节码后转换成流，然后调用 defineClass（）方法生成类的Class 对象==** 

简单举例：

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
// 获取类的class文件字节数组
byte[] classData = getClassData(name);
if (classData == null) {
throw new ClassNotFoundException();
} else {
//直接生成class对象
return defineClass(name, classData, 0, classData.length);
}
}
```



> **protected final void resolveClass（Class<?> c）** 

链接指定的一个 Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类交量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用



> **protected final Class<?> findLoadedClass（String name）** 

查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改



> **private final ClassLoader parent** 

它也是一个 ClassLoader 的实例，这个字段所表示的 ClassLoader 也称为这个 ClassLoader 的双亲。在类加载的过程中，ClassLoader 可能会将某些请求交予自己的双亲处理



## 5、SecureClassLoader、URLClassLoader

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-29_08-46-33.png)



SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对 Class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类   URLClassLoader 有所关联

前面说过，ClassLoader 是一个抽象类，很多方法是空的没有实现，比如 findClass（）、findResource（）等。而URLClassLoader 这个实现类为这些方法提供了具体的实现。并新增了 URLClassPath 类协助取得 Class 字节码流等功能

**在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类**，这样就可以避免自己去编写 findClass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁



> Class.forName（）与 ClassLoader.loadClass（）

**Class.forName（）是一个==静态方法==**，最常用的是 Class.forName（ String className），根据传入的类的全限定名返回一个 Class 对象。**该方法在将 Class 文件加载到内存的同时，==会执行类的初始化==** 

**ClassLoader.loadClass（）是一个==实例方法==**，需要一个 ClassLoader 对象来调用该方法。**该方法将 Class 文件加载到内存时，==并不会执行类的初始化==**，直到这个类第一次使用时才进行初始化。该方法因为需要得到 ClassLoader 对象，所以可以根据需要定使用哪个类加载器



## 6、双亲委派机制

> 定义

如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父加载器去完成，依次递归，如果父加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载仼务时，才自己加载

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/Snipaste_2020-09-29_15-43-25.png)



### 优势

1、避免类的重复加载，确保一个类的全局唯一性

Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以**免类的重复加载**，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次

2、保护程序安全，防止核心 API 被随意篡改

JDK 为核心类库提供了一层保护机制。**不管是自定义的类加载器，还是系统类加载器或扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass（String，byte[]，int，int，ProtectionDomain）方法，而该方法会执行 preDefineClass（）接口，该接口中提供了对 JDK 核心类库的保护** 



亲委派机制在 **java.lang.ClassLoader.loadClass（String，boolean）**接口中体现。该接口的逻辑如下

1、先在当前加载器的缓存中查找有无日标类，如果有，直接返回

2、判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass（name, false）接口进行加载

3、如果当前加载器的父类加载器为空，则调用 findBootstrapClassOrNull（name）接口，让引导类加载器进行加载

4、如果通过以上 3 条路径都没能成功加载，则调用 findClass（name）接口进行加载。该接口**最终会调用   java.lang.Cl assLoader 接口的 defineClass 系列的 native 接口加载目标** 

Java 类双亲委派的模型就隐藏在这第 2 和第 3 步中



### 弊端

检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题，即顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类

通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，**应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题** 

比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题



> 结论

**由于 Java 虚拟机规范其没有明确要求类加载器的加载机制一定要使用双亲委派模型**，只是建议釆用这种方式而已，比如在 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，**首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的父加载器去执行**，这同时也是Servlet 规范推荐的一种做法



### 破坏双亲委派机制

> 第一次破坏

双亲委派模型的第一次 “被破坏” 其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的 “远古” 时代

由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就己经存在

面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，**为了兼容这些已有代码，无法再以技术于段避免 loadClass（）被子类覆盖的可能性**，只能在 JDK 1.2 之后的 java.lang.ClassLoader中添加一个新的 protected 方法 findClass（），并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在   loadClass（）中编写代码

己经分析过 loadClass（）方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass（）方法的逻辑，如果父类加载失败，会自动调用自己的 findClass（）方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的



> 第二次破坏

**双亲委派模型的第二次 “被破坏” 是由这个模型==自身的缺陷==导致的**，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加載），基础类型之所以被称为 “基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序没计往往没有绝对不变的完美规则，**如果有基础类型要调用用户的代码？** 

这并非是不可能出现的事情，一个典型的例了便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器来完成加载（在 JDK 1.3 时加入到 rt.jar 的），肯定属于 Java 中很基础的类型了

但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的服务提供者接口（Service provider interface，SPI ）的代码，现在问题来了，**启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？** 

* SPI：在 Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI

为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的没计：**==线程上下义类加载器==**。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader（）方法进行设置，如果建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范国内都没有设置过的话，那这个类加载器默认就是应用程序类加载器

有了线程上下文类加载器，程序就可以做一些 “舞弊” 的事情了。**JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码，这是一种==父加载器去请求子加载器完成类加载的行为==**，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB、JBI 等

不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不雅的实现方式，在 JDK 6 时，JDK 提供了 java.util.ServiceLoader 类，以 META-INF / services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案



> 第三次破坏

双亲委派模型的第三次 “被破坏” 是由于**用户对程序动态性的追求**而导致的。如：代码热替换（ Hot Swap）、模块热部署（ Hot Deployment）等

IBM 公司主导的 JSR-291（即 OSGi  R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构

当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

1、将以 java.* 开头的类，委派给父类加载器加载

2、否则，将委派列表名单内的类，委派给父类加载器加载

3、否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载

4、否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载

5、否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载

6、否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加器加载

7、否则，类查找失败

说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的



## 7、自定义类加载器



> 为什么要自定义类加载器

**==隔离加载类==**：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序

**==修改类的加载方式==**：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载

**==扩展资源==**：比如从数据库、网络、甚至是电视机机顶盒进行加载

**==防止源码泄漏==**：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节



> 常见的场景

实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是 J ava EE 和 OSGI、JPMS 等框架

应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型



注意：

在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及 Java 类型转换则加载器反而容易产生不美好的事情。**在做 Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常** 





### 实现

Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类

在自定义 ClassLoader 的子类时候，我们常见的会有两种做法：

1、重写 loadClass（）方法

2、重写 findClass（）方法（推荐）

这两种方法本质上差不多，**毕竞 loadClass（）也会调用 findClass（）**，但是从逻辑上讲我们最好不要直接修改loadClass（）的内部逻辑。**建议的做法是只在 findClass（）里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用** 

loadClass（）这个方法是实现双亲委派模型逻的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也邂免了自己重写 loadClass（）方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择

当编写好自定义类加载器后，使可以在程序中调用 loadClass（）方法来实现类加载操作

例子

```java
package com.atguigu.java2;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;

/**
 * @author shkstart
 * @create 15:20
 * 自定义ClassLoader
 */
public class MyClassLoader extends ClassLoader {
private String byteCodePaht;

public MyClassLoader(String byteCodePaht) {
this.byteCodePaht = byteCodePaht;
}

public MyClassLoader(ClassLoader parent, String byteCodePaht) {
super(parent);
this.byteCodePaht = byteCodePaht;
}

@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
BufferedInputStream bis = null;
ByteArrayOutputStream out = null;
String fileName = byteCodePaht + name + ".class";
try {
bis = new BufferedInputStream(new FileInputStream(fileName));
out = new ByteArrayOutputStream();

int len = 0;
byte[] bytes = new byte[1024];
while ((len = bis.read(bytes)) != -1) {
out.write(bytes, 0, len);
}

byte[] bytes1 = out.toByteArray();
Class<?> aClass = defineClass(null, bytes1, 0, bytes1.length);
return aClass;

} catch (IOException e) {
e.printStackTrace();
} finally {
try {
out.close();
} catch (IOException e) {
e.printStackTrace();
}
try {
bis.close();
} catch (IOException e) {
e.printStackTrace();
}
}
return null;
}
}
```

```java
public class MyClassLoaderTest {
public static void main(String[] args) {
MyClassLoader loader = new MyClassLoader("C:\\Users\\tfc\\Desktop\\2\\");

try {
Class clazz = loader.loadClass("Demo1");
System.out.println("加载此类的类的加载器为：" + clazz.getClassLoader().getClass().getName());

System.out.println("加载当前Demo1类的类的加载器的父类加载器为：" + clazz.getClassLoader().getParent().getClass().getName());
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
}
```

