# 	            内存与垃圾回收



# 一、JVM 与 Java 体系结构

## 1 、JVM 的整体结构

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200604115700.png)





## 2、Java 程序执行过程

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200605083821.png)



## 3、JVM 的架构模型

**Java** 编译器输入的指令流基本上是一种**==基于栈==的指令集架构** 

另外一种指令集架构则是**==基于寄存器==的指令集架构** 



### 3.1 基于栈的指令集架构

* 设计和实现更简单，适用于资源受限的系统
* 避开了寄存器的分配难题：使用**零地址指令方式分配** 
* 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小编译器容易实现
* 不需要硬件支持，可移植性更好，更好实现跨平台



> 零地址指令、一地址指令、二地址指令

一地址指令：一个地址、一个操作数

二地址指令：两个地址、一个操作数

零地址指令：没有地址，只有操作数，因为每次操作的都是栈顶指令，不需要地址



### 3.2 基于寄存器的指令集架构

* 典型的应用是 **x86** 的二进制指令集：比如传统的 **PC** 以及 **Android** 的 **Davlik** 虚拟机
* 指令集架构则**完全依赖硬件，可移植性差** 
* 性能优秀和执行更高效花费更少的指令去完成一项操作
* 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主



## 4、JVM 的声明周期

### 4.1 虚拟机的启动

Java 虚拟机的启动是通过**引导类加载器**（bootstrap class loader）创建一个**初始类**（initial class）来完成的，这个类是由虚拟机的具体实现指定的



### 4.2 虚拟机的执行

* 一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序
* 程序开始执行时他才运行，程序结束时他就停止
* **执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程** 



### 4.3 虚拟机的退出

有如下几种情况

* 程序正常执行结束
* 程序在执行过程中遇到了异常或错误而异常终止
* 由于操作系统出现错误而导致Java虚拟机进程终止
* 某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 的 halt 方法，并且 Java 的安全管理器也允许这次 exit 或 halt 操作
* 除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退岀情况



# 二、类加载子系统

## 1、内存结构

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200605105159.png)



## 2、加载过程

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200605110409.png)

* 类加载器子系统负责从文件系统或者网络中加载 **.class** 文件，**.class** 文件在文件开头有特定的文件标识
* **Classloader** 只负责 **class** 文件的加载，至于它是否可以运行，则由 **Execution Engine**决定
* 加载的类信息存放于一块称为**==方法区==**的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 **Class** 文件中常量池部分的内存映射）

### 2.1 加载阶段（Loading）

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法的运行时数据结构
3. **在内存中生成一个代表这个类的 ==java.lang.Class== 对象**，作为方法区这个类的各种数据的访问入口



### 2.2 链接阶段（Linking）

1、验证（**Verify**）

* 目的在于确保 **class** 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
* 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证

2、准备（**Prepare**）

* 为**==类变量==**分配内存并且**设置该类变量的默认初始值，即==零值==** 
* 这里不包含用 **final** 修饰的 **static**，因为 **final** 在编译的时候就会分配了，准备阶段会显式初始化
* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到**Java**堆中

3、解析（**Resolve**）

* 将常量池内的**符号引用转换为直接引用**的过程
    * 事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行
    * **符号引用**就是用一组符号来描述所引用的目标。**符号引用**的字面量形式明确定义在《Java 虚拟机规范》的**class** 文件格式中
    * **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
* 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的
    * **CONSTANT_Class_info，CONSTANT_Fieldref_info，CONSTANT_Methodref_info** 



### 2.3 初始化（Initialization）

> 初始化阶段就是执行类构造器方法 <c1init>（）的过程

* 此方法不需定义，是 **javac** 编译器自动收集类中的所有**==类变量==**的赋值动作和**==静态代码块==**中的语句合并而来
* 构造器方法中指令按语句在源文件中出现的顺序执行
* 若该类具有父类，**JVM** 会保证子类的 <c1init>（）执行前，父类的 <c1init>（）已经执行完毕
* 虚拟机必须保证一个类的 <c1init>（）方法**在多线程下被同步加锁** 

> <c1init>（）不同于类的构造器，构造器是虚拟机视角下的<init>（）



## 3、类加载器

JVM 支持两种类型的类加载器

* 引导类加载器（**Bootstrap ClassLoader**）
* 自定义类加载器（**User - Defined ClassLoader**）
    * 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是**将所有派生于抽象类 ==Classloader== 的类加载器都划分为自定义类加载器** 



常用的类加载器有三类

1、引导类加载器（C/C++ 编写的，获取不到对象）

> **Bootstrap ClassLoader** 

2、扩展类加载器

> **Extension  ClassLoader** 

3、系统类加载器

> **System  ClassLoader** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200605180644.png)



### 3.1 引导类加载器

* 也叫启动类加载器
    * 这个类加载器使用 **C/C++** 语言实现的，嵌套在 **JVM** 内部
    * 它用来加载 **Java** 的核心库（ **JAVA_HOME/jre/lib/rt.jar、resources.jar** 或 **sun.boot.class.path** 路径下的内容），用于提供 **JVM** 自身需要的类
    * 并不继承自 **Java.lang.Classloader**，没有父加载器
    * 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
    * 出于安全考虑， **Bootstrap** 启动类加载器只加载包名为 **java、 javax、 sun** 等开头的类



### 3.2 扩展类加载器

* **Java** 语言编写，由 **sun.misc.Launcher$ExtClassLoader** 实现
* 派生于 **ClassLoader** 类
* 父类加载器为**启动类加载器** 

* 加载内容
    * 从 **java.ext.dirs** 系统属性所指定的目录中加载类库，或从 **JDK** 的安装目录的 **jre/lib/ext** 子目录（扩展目录）下加载类库
    * **如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载** 



### 3.3 系统类加载器

也叫 **应用程序类加载器（AppClassLoader）**

* 由 **Java** 语言编写，由 **sun.misc.Launcher$AppClassLoader** 实现
* 派生于 ClassLoader 类
* 父类加载器为**扩展类加载器** 
* 加载内容
    * 它负责加载环境变量 **classpath** 或系统属性 **java.class.path** 指定路径下的类库
* 该类加载是程序中默认的类加载器
    * 一般来说，**Java** 应用的类都是由它来完成加载



## 4、ClassLoader

获取 ClassLoader 的途径

1、获取当前类的 ClassLoader

> clazz.getClassLoader()

2、获取当前线程上下文的 ClassLoader

> Thread.currentThread().getContextClassLoader()

3、获取系统的 ClassLoader

> ClassLoader.getSystemClassLoader()

4、获取调用者的 ClassLoader

> DriverManager.getCallerClassLoader()



## 5、双亲委派机制

概念

* **Java** 虚拟机对 **class** 文件采用的是按需加载的方式
    * 也就是说当需要使用该类时才会将它的 **class** 文件加载到内存生成 **class** 对象
* 而且加载某个类的 **class** 文件时，**Java** 虚拟机采用的是**双亲委派模式** 
    * 即把请求交由父加载器处理，它是一种**任务委派模式** 



原理

1. **如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是先把这个请求委托给父加载器去执行** 
2. 如果父类加载器还存在其父加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是**双亲委派模式** 



举例

* 我们自己新建一个 **java.lang.String** 类，看看是否会加载自定义的 **String** 类

自定义 **String** 类

* 在 **java.lang** 包下新建一个 **String** 类

```java
package java.lang;  // 在 java.lang 包下新建一个 String 类

public class String {
    // 看看是否会加载自定义的 String 类
    static {
    System.out.println("自定义 String 类");
    }
}
```

测试

```java
public class TestClassLoader {
    public static void main(String[] args) {
    // 看看 new 的到底是 JDK 自带的还是自定义的
    String s = new String(); // 默认值为 ""
    System.out.println("JDK 自带 String 类");
    System.out.println(s.getClass());
    }
}
```

输出结果

```java
JDK 自带 String 类
class java.lang.String
```

解释

> ​	当 new 一个 String 对象的时候，系统类加载器会将加载任务交给父加载器（扩展类加载器）来完成，同样，扩展类加载器会将加载任务交给父加载器（启动类加载器）来完成，如果不能再向下传递。当启动类加载器收到加载任务后判断是自己可以加载的类型，所以就从核心类库中加载，而不是加载自定义的类

优势

1. 避免类的重复加载
2. 保护程序安全，防止**核心 API** 被随意篡改



## 6、沙箱安全机制

> ​	自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中 java.lang.String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是**==沙箱安全机制==** 



## 7、类加载细节

> 如何判断两个 class 对象是否为同一个类

1. 类的全限定类名必须一致
2. 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同



> 类的主动使用和被动使用

区别

* **主动使用**会进行**类的初始化**，**被动使用**不会进行初始化，只会加载

主动使用

1. 创建类的实例
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（比如：Class.forName（"com. atguigu.Test"））
5. 初始化一个类的子类
6. Java 虚拟机启动时被明确标志为需要启动的类
7. JDK 7 提供的动态语言支持



# 三、运行时数据区

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200606115029.png)



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200606115236.png)





> Java 虚拟机定义了若干种程序运行期间会使用到的**运行时数据区**，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁



举例：灰色的为单独线程私有的，红色的为多个线程共享的

> 每个线程：独立包括程序计数器、栈、本地栈
> 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200606115807.png)



## 1、程序计数器

* 也叫 PC 寄存器

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607075204.png)

> ​	这里，并非是广义上所指的物理寄存器，或许将其翻译为 **PC 计数器（或指令计数器）**会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。**JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟** 



作用

> PC 寄存器用来**存储指向下一条指令的地址，也即将要执行的指令代码**。由执行引擎读取下一条指令

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607075508.png)

* 是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域
* 在 **JVM** 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
* 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法
    * 程序计数器会存储当前线程正在执行的 **Java** 方法的 **JVM** 指令地址
    * 或者如果是在执行 **native**方法，则是未指定值（ undefined）
* 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
* 宇节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
* 它是唯一一个在 **Java** 虚拟机规范中没有规定任何 **OutOfMemoryError** 情况的区域



### 1.1 相关问题

> 使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？

因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令



> PC寄存器为什么会被设定为线程私有？

1、我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况

2、由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令



## 2、虚拟机栈

> 栈是运行时的单位，而堆是存储的单位

* 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据
* 堆解决的是数据存储的问题，即数据怎么放、放在哪儿



> 什么是 Java 虚拟机栈

* **Java** 虚拟机栈，早期也叫 **Java** 栈
* 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的==**栈帧**==，对应着一次次的 **Java** 方法调用
* 是线程私有的，声明周期和线程一致

> Java 虚拟机栈的作用

* 主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回

> 栈的优点

* 栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器** 
* JVM 直接对 Java 栈的操作只有两个
    * 每个方法执行，伴随着进栈（入栈、压栈）
    * 执行结束后的出栈工作
* **对于栈来说不存在垃圾回收问题** 



### 2.1 栈的常见异常

> Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的

如果采用固定大小的 **Java** 虚拟机栈，那每一个线程的 **Java** 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 **Java** 虚拟机栈允许的最大容量，**Java** 虚拟机将会抛出一个 **StackOverflowError** 异常

如果 **Java** 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 **OutOfMemoryError** 异常



### 2.2 设置栈的大小

> 我们可以使用参数 ==**-Xss**== 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度
>
> 单位可以是：K、M、G

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607124240.png)

* 可以用递归来检验栈的最大可达深度



### 2.3 栈的存储单位

> 每个线程都有自己的栈，栈中的数据都是以**==栈帧（ Stack frame）==**的格式存在
>
> 在这个线程上正在执行的**每个方法都各自对应一个栈帧（ stack Frame）** 
>
> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息



### 2.4 栈的运行原理

* JVM 直接对 Java 栈的操作只有两个
    * 就是对栈帧的压栈和出栈，遵循 “先进后出” / “后进先出” 原则
* 在一条活动线程中，一个时间点上，只会有一个活动的栈帧
    * 即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧
    * 当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
* 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧
* 不同线程中所包含的栈帧是不允许存在相互引用的
    * 即不可能在一个栈帧之中引用另外一个线程的栈帧
* 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
* **Java** 方法有两种返回函数的方式，不管使用哪种方式，都会导致栈帧被弹出
    * 一种是正常的函数返回，使用 **return** 指令
    * 一种是抛出异常

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607151238.png)



### 2.5 栈帧的结构

> * 局部变量表（Loca1 Variab1es）
> * 操作数栈（ Operand Stack）（或表达式栈）
> * 动态链接（ Dynamic Linking）（或指向运行时常量池的方法引用）
> * 方法返回地址（ Return Address）（或方法正常退出或者异常退出的定义）
> * 一些附加信息

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607154214.png)

#### 2.5.1 局部变量表

> 局部变量表也被称之为局部变量数组或本地变量表

* **定义为一个字节数组，主要用于存储方法参数和定义在方法体内的局部变量** 
    * 这些数据类型包括各类基本数据类型、对象引用（ reference），以及 **returnAddress** 类型
* 由于局部变量表是建立在线程的栈上，是线程的私有数据，没有涉及共享，因此不存在数据安全问题
* **局部变量表所需的容量大小是在==编译期==确定下来的** 
    * 保存在方法的 **code** 属性的 **maximum local variables** 数据项中
    * 在方法运行期间是不会改变局部变量表的大小的



> 局部变量表的变量槽 **==slot==** 

* 局部变量表是一个数组，每一个数据单元叫一个槽

* 在局部变量表里，32 位以内的类型只占用一个 **slot**（如 **returnAddress**），64位的类型（**long** 和 **double**）占用两个 **slot** 
    * **byte、short、char** 在存储前被转换为 **int, boolean** 也被转换为 **int**，0 表示 **fa1se**，非 0 表示 **true** 
    * **long** 和 **double** 则占据两个 **slot** 
* **JVM** 会为局部变量表中的每一个 **slot** 都分配一个访问索引，通过这个素引即可成功访问到局部变量表中指定的局部变量值
* 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复**制到局部变量表中的每一个 **slot** 上
* **如果需要访问局部变量表中一个 64 bit 的局部变量值时，只需要使用前一个索引即可** 
    * 比如：访问 **long** 或 **double** 类型变量
* 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用 this 将会存放在 index 为 0 的 slot 处**，其余的参数按照参数表顺序继续排列

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200607184647.png)

> slot 的重复利用

* 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的



> 静态变量与局部变量的对比

* 我们知道**类变量**有两次初始化的机会
    * 第一次是在 “准备”阶段，执行系统初始化，对**==类变量==**设置零值
    * 另一次则是在 “初始化” 阶段，赋予程序员在代码中定义的初始值
* 和类变量初始化不同的是，局部变量表不存在系统初始化的过程
    * 这意味着**一旦定义了局部变量则必须人为的初始化，否则无法使用** 

```java
public void test02() {
    int num;
    System.out.println(num); 
}
```

* 这样的代码是错误的，**局部变量声明时没有赋值无法使用** 



#### 2.5.2 操作数栈

> 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的**操作数栈**，也可以称之为表达式栈

* 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/ 出栈（pop）
    * 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈
    * 比如：执行复制、交换、求和等操作

代码举例

> Java 代码

```java
public void test02() {
    byte i = 15;
    int j = 13;
    int k = i + j;
}
```

> 字节码指令

```java
 0 bipush 15
 2 istore_1
 3 bipush 13
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 return
```



#### 2.5.3 栈顶缓存技术

> ​	前而提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（ instruction dispatch ）次数和内存读 / 写次数
>
> ​	由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题 HotSpot JVM 的设计者们提出了栈顶缓存（ToS，Top-of- Stack Cashing）技术，将栈顶元素全部**缓存在物理 CPU 的寄存器中**，以此降低对内存的读/写次数，提升执行引擎的执行效率



#### 2.5.4 动态链接

* 指向运行时常量池的方法引用

> 每一个栈帧内部都包含一个指向==**运行时常量池**==中==**该栈帧所属方法**==的引用
>
> 包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（ Dynamic Linking ）
>
> 比如：**invokedynamic** 指令

* 在 **Java** 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**保存在 **class** 文件的常量池里
* 比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200614095325.png)



#### 2.5.5 方法的调用

* 绑定

> 绑定是一个**==字段、方法或者类==**在符号引用**==被替换为直接引用==**的过程，这仅仅发生一次



* 静态链接

> ​	当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法**==在编译期可知且运行期保持不变==**，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

* 早期绑定

> ​	早期绑定就是指**==被调用的目标方法如果在编译期可知，且运行期保持不变==**时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，囚此也就可以使用静态链接的方式将符号引用转换为直接引用



* 动态链接

> ​	如果被调用的方法**==在编译期无法被确定下来==**，也就是说，只能够在**==程序运行期==**将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

* 晚期绑定

> ​	如果被调用的方法**==在编译期无法被确定==**下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定



* 非虚方法和虚方法

> 如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的，这样的方法称为**非虚方法** 
>
> 如：静态(static)方法，私有(private)方法，final 方法，实例构造器，父类方法
>
> 其他方法称为**虚方法** 



* 方法的调用指令

> **invokestatic**：调用诤态方法，解析阶段确定唯一方法版本
>
> **invokespecial**：调用<init>方法、私有方法、父类方法，解析阶段确定唯一方法版本
>
> **invokevirtual**：调用所有虚方法
>
> **invokeinterface**：调用接口方法
>
> **invokedynamic**：动态解析出需要调用的方法，然后执行



#### 2.5.6 方法返回地址

> 存放调用该方法的 pc 寄存器的值

一个方法的结束，有两种方式：

* 正常执行完成

* 出现未处理的异常，非正常退出

​	无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息



## 3、本地方法接口

> 什么是本地方法？

简单地讲，一个 **Native Method** 就是一个 Java 调用**非 Java 代码**的接口

一个 **Native Method** 是这样一个 Java 方法

* 该方法的实现**由非 Java 语言实现**，比如C

​    这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用 extern"c" 告知 c++ 编译器去调用一个 c 的函数

> ​	在定义一个 **native method** 时，并**不提供实现体**（有些像定义一个**Java interface**），因为其实现体是由**非 Java 语言在外面实现的** 

本地接囗的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序



举例

```java
public native void method();
```

* 由 **native** 关键字修饰，没有方法体，不能与 **abstract** 连用



### 1、为什么要使用本地方法

> Java 使用起来非常方便，但有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了



#### 1.1 与 Java 外部环境交互

**有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因** 

你可以想想 **Java** 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况

本地方法正是这样一种交流机制

* 它为我们提供了一个非常简洁的接口而且我们无需去了解 **Java** 应用之外的繁琐的细节



#### 1.2 与操作系统进行交互

​	**JVM** 支持着 **Java** 语言本身和运行时库，它是 **Java** 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成

​	然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统通过使用本地方法，我们得以用 **Java** 实现了 **jre** 的与底层系统的交互，甚至 **JVM** 的一些部分就是用 C 写的，还有，如果我们要使用一些 **Java** 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法



#### 1.3 Sun's Java

**Sun** 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互

​	**JRE** 大部分是用 **Java** 实现的，它也通过一些本地方法与外界交互。例如：类 **java.lang**， **Thread** 的 **setpriority()** 方法是用 **Java** 实现的，但是它实现调用的是该类里的本地方法 **setpriority0()**。这个本地方法是用 C 实现的，并被植入 **JVM** 内部，在 **Windows95** 的平台上，这个本地方法最终将调用 **Win32 Setpriority() API**。这是一个本地方法的具体实现由 **JVM** 直接提供，更多的情况是本地方法由外部的动态链接库提供，然后被 **JVM** 调用



## 4、本地方法栈

* **Java** 虚拟机栈用于管理 **Java**方法的调用，而本地方法栈用于管理本地方法的调用
* 本地方法栈，也是线程私有的
* 允许被实现成固定或者是可动态扩展的内存大小
    * 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，**Java** 虚拟机将会抛出一个 **StackOverflowError** 异常
    * 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 **Java** 虚拟机将会抛出一个 **OutOfMemoryError** 异常
* 本地方法是使用 C 语言实现的
* 它的具体做法是 **Native Method Stack** 中登记 **native**方法，在 **Excution Engine** 执行时加载本地方法库



> 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限

* 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区

* 它甚至可以直接使用本地处理器中的寄存器

* 可以直接从本地内存的堆中分配任意数量的内存



## 5、堆

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200618180118.png)

### 5.1 堆的核心概述

* 一个 **JVM** 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域
* **Java** 堆区在 **JVM** 启动的时候即被创建，其空间大小也就确定了。是 **JVM** 管理的最大一块内存空间
    * 堆内存的大小是可以调节的
* 《 **Java** 虚拟机规范》规定，堆可以处于**物理上不连续**的内存空间中，但在**逻辑上**它应该被视为**连续**的
* 所有的线程共享 **Java** 堆，在这里还可以划分线程私有的缓冲区
* 《**Java**虚拟机规范》中对 **Java** 堆的描述是：所有的**对象实例、数组**都应当在运行时分配在堆上
    * 从实际使用角度来看：“几乎” 所有的对象实例都在堆分配内存，可能还有一部分在栈中分配内存
* 数组和对象可能永远不会存储在栈上
    * 因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
* 堆是 GC（ Garbage Collection，垃圾收集器）执行垃圾回收的重点区域



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200623212214.png)



### 5.2 堆内存的细分

现代垃圾收集器大部分都基于分代收集理论设计

> **Java 7** 及之前堆内存==**逻辑上**==分为三部分：新生区 + 养老区 + **==永久区==** 

> **Java 8** 之后堆内存==**逻辑上**==分为三部分：新生区 + 养老区 + **==元空间==** 

* 新生区又被分为了 **Eden** 区和 **Survivor** 区



### 5.3 设置堆空间的大小

> -Xms：堆空间的起始内存，等价于 -XX:InitialHeapsize
>
> -Xmx：堆空间的最大内存，等价于 -XX:MaxHeapsize
>
> 默认情况下，
>
> ​	初始内存大小：物理电脑内存大小 / 64
>
> ​	最大内存大小：物理电脑内存大小 / 4

* 一旦堆区中的内存大小超过 **"-Xmx"** 所指定的最大内存时，将会抛出 **OutOfMemoryError** 异常
* 通常会将 -Xms 和 -Xmx 两个参数**设置相同的值**，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200623215805.png)





### 5.4 年轻代与老年代

存储在 **JVM** 中的 **Java** 对象可以被划分为两类

* 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
* 一类对象的生命周期却非常长，在某些极端的情况下还能够与 **JVM** 的生命周期保持一致

**Java** 堆区进一步细分的话，可以划分为**年轻代（ YoungGen）和老年代（ oldGen）** 

* 其中年轻代又可以划分为 **Eden** 空间、 **Survivor0** 空间和 **Survivor1** 空间（有时也叫做 from 区、to 区）

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701103022.png)



配置新生代与老年代在堆结构的占比（一般不需要调整）

* 默认 **-XX:NewRatio=2**，表示新生代占1，老年代占2，新生代占整个堆的 1/3
* 可以修改 **-XX:NewRatio=4**，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701103451.png)



配置新生代中的各区域的比例

* 默认 **Eden** 空间和另外两个 **Survivor** 空间所占的比例是 **8 : 1 : 1**
    * 实际过程中默认有个自适应策略，比例可能不对，需要手动设置参数
* 可以通过选项 **“-XX:SurvivorRatio”** 调整这个空间比例
    * 例：**-XX:SurvivorRatio=8**



* **Eden** 区域介绍

> 1、几乎所有的 Java 对象都是在 Eden 区被 new 出来的
>
> 2、绝大部分的 Java 对象的销毁都在新生代进行了
> 	IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的
>
> 3、可以使用选项 "-Xmn" 设置新生代最大内存大小
> 	这个参数一般使用默认值就可以了



### 5.5 对象分配过程

1、**new** 的对象先放伊甸园区，此区有大小限制

2、当 **Eden** 的空间填满时，程序又需要创建对象，**JVM** 的垃圾回收器将对 **Eden** 区进行垃圾回收（ **Minor gc**），将 **Eden** 区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到 **Eden** 区

3、然后将 **Eden** 中的剩余对象移动到 **Survivor0** 区

4、如果再次触发垃圾回收，此时上次幸存下来的放到 **Survivor==0==** 区的，如果没有回收，就会放到 **Survivor==1==** 区

5、如果再次经历垃圾回收，此时会重新放回 **Survivor0** 区，接着再去 **Survivor1** 区

6、啥时候能去养老区呢？**由 GC 次数决定，可以设置次数。默认是15次** 

* 可以设置参数：**-XX:MaxTenuringThreshold=**<N> 进行设置

7、在养老区，相对悠闲。当养老区内存不足时，再次触发 **GC（Major Go）**，进行养老区的内存清理

8、若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 **OOM** 异常



* 图解

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701110609.png)

> 当 **Eden** 区域满了之后，进行垃圾回收（Minor GC），清除不需要的对象的引用，将剩余对象放到 **s0** 区域



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701111035.png)

> 当 **Eden** 区域又满了之后，进行垃圾回收（Minor  GC），这时候 **s0** 区域的也要进行判断，还存在的对象全部放到 **s1** 区域
>
> 每进行一次垃圾回收，幸存对象不断在 s0 和 s1 区域变换，变换一次计数加 1



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701111643.png)

> 当 GC 次数到达 15（默认）后，还存在的对象被移到老年区

可以修改达到送往老年区的条件（计数次数）

* 可以设置参数：**-XX:MaxTenuringThreshold=**<N> 进行设置



* 完整流程图

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701114616.png)



**==Eden 区满了之后会触发垃圾回收，但 Survivor 区满了之后不会触发垃圾回收==** 



#### 5.5.1 垃圾收集算法介绍

> ​	JVM 在进行 GC 时，并非每次都对三个内存（新生代、老年代：方法区）区域一起回收的，大部分时候回收的都是指新生代

针对 **HotSpot JVM** 的实现，它里面的 **GC** 按照回收区域又分为两大种类型

* **部分收集、整堆收集** 



> 部分收集：不是完整收集整个 **Java** 堆的垃圾的收集

* 新生代收集（ Minor GC/ Young GC）：只是新生代的垃圾收集
* 老年代收集（ Major Gc/Old Gc）：只是老年代的垃圾收集
    * 目前，只有 **CMS GC** 会有单独收集老年代的行为
    * 注意，很多时候 **Major Gc** 会和 **Full Gc**混淆使用，需要具体分辨是**老年代回收**还是**整堆回收** 
* 混合收集（ Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    * 目前，只有 **G1 GC** 会有这种行为

> 整堆收集（**Full  GC**）：收集整个 **==Java 堆和方法区==**的垃圾收集



#### 5.5.2 Minor GC

* 触发条件

> ​	当年轻代空间不足时，就会触发 **Minor GC**，这里的年轻代满指的是 **Eden** 区满， **Survivor** 区满不会引发GC（每次 Minor GC 会清理年轻代的内存）
>
> 因为 **Java** 对象大多都具备朝生夕灭的特性，所以 **==Minor GC 非常频繁==**，一般回收速度也比较快
>
> **Minor GC** 会引发 **STW（Stop the World）**，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行



#### 5.5.3 Major GC

* 触发条件

> 指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full Gc” 发生了
>
> ​	出现了 **Major GC**，经常会伴随至少一次的 **Minor GC**（并非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程），也就是在老年代空间不足时，会先尝试触发 **Minor GC**，如果之后空间还不足，则触发 **Major GC** 
>
> **Major GC** 的速度一般会**比 Minor GC 慢 10 倍以上**，STW 的时间更长
>
> 如果 **Major GC** 后，内存还不足，就报 **OOM** 了



#### 5.5.4 Full GC

* 触发机制：触发 **Full  GC** 执行的情况有如下五种

> 1、调用 **System.gc()** 时，系统建议执行 **Full  GC**，但是不是必然执行
>
> 2、老年代空间不足
>
> 3、方法区空间不足
>
> 4、通过 **Minor GC** 后进入老年代的平均大小大于老年代的可用内存
>
> 5、由 **Eden** 区、 **survivor space0（ From Space）**区向 **survivor space1（To Space）**区复制时，对象大小大于 **To Space** 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小



#### 5.5.5 内存分配策略

* 优先分配到 **Eden** 区
* **==大对象==直接分配到老年代** 
    * 尽量避免程序中出现过多的大对象
* 长期存活的对象分配到老年代
* 动态对象年龄判断
    * 如果 **Survivor** 区中相同年龄的所有对象大小的总和大于 **Survivor** 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 **MaxTenuringThreshold** 中要求的年龄
* 空间分配担保
    * **-XX:HandlepromotionFailure** 



#### 5.5.6 为对象分配内存：TLAB

> 为什么有 **TLAB（Thread Local Allocation Buffer）**

* 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
* 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
* 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度



> 什么是 **TLAB**

* 从内存模型而不是垃圾收集的角度，对 **Eden** 区域继续进行划分，**JVM 为每个线程分配了一个私有缓存区域**，它包含在 **Eden** 空间内
* 多线程同时分配内存时，使用 **TLAB** 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们**可以将这种内存分配方式称之为快速分配策略** 
* 据我所知所有 **OpenJDK** 衍生出来的 **JVM** 都提供了 **TLAB** 的设计

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701153745.png)



> **TLAB** 的说明

* 尽管不是所有的对象实例都能够在 **TLAB** 中成功分配内存，但 **JVM** 确实是将 **TLAB** 作为内存分配的首选
* 在程序中，开发人员可以通过选项 `-xx:UseTLAB` 设置是否开启 **TLAB** 空间
* **默认情况下，TLAB 的空间非常小，仅占整个 Eden 区域的 1%** 
    * 可以通过选项`-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用 Eden 空间的百分比大小
* 一旦对象在 **TLAB** 空间分配内存失败时，**JVM** 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在**Eden** 空间中分配内存

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200701154828.png)



### 5.6 常用堆空间参数设置

> -XX:+PrintFlagsInitial：查看所有的参数的默认初始值

> -XX:PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）

* 查看具体某个参数的值（命令行）
    * **jps**：查看运行中的进程（Java）
    * **jinfo  -flag**  参数名  进程ID

> -Xms：初始堆空间内存（默认为物理内存的 1/64）

> -Xmx：最大堆空间内存（默认为物理内存的1/4）

> -Xmn：设置新生代的大小（初始值及最大值）

> -XX:NewRatio：配置新生代与老年代在堆结构的占比

> -XX:SurvivorRatio：设置新生代中 Eden 和 s0/s1 空间的比例

> -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄

> -XX:+PrintGCDetails：输出详细的 GC 处理日志
> 	打印 GC 简要信息：-XX:+PrintGC、-verbose:gc



> -XX:+DoEscapeAnalysis：显式开启逃逸分析
> -XX:+PrintEscapeAnalysis：查看逃逸分析的筛选结果



> -XX:HandlePromotionFailure：是否设置**空间分配担保**

解释

在发生 **Minor GC** 之前，虚拟机会检查老年代**最大可用的连续空间是否大于新生代所有对象的总空间**，如果大于，则此次 **Minor GC** 是安全的，如果小于，则虚拟机会查看 **-XX:HandlePromotionFailure** 设置值是否允许担保失败

* 如果 **HandlePromotionFailure=true**，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
    * 如果大于，则尝试进行一次 **Minor GC**，但这次 **Minor GC** 依然是有风险的
    * 如果小于，则改为进行一次 **Full GC** 
* 如果 **HandlepromotionFailure=fa1se**，则改为进行一次 **Full GC** 

> ​	在 **JDK 6 Update24（JDK7）**之后， **HandlePromotionFailure** 参数不会再影响到虚拟机的空间分配担保策略，虽然源码中还定义了**Handlepromotionfailure** 参数，但是在代码中已经不会再使用它
>
> **JDK6 Update 24（JDK7）**之后的规则变为：
> 	只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 **Minor GC**，否则将进行 **Full GC** 



### 5.7 逃逸分析

​	在《深入理解 Java 虛拟机》中关于 Java 堆内存有这样一段描述随着 **JIT** 编译期的发展与**==逃逸分析技术==**逐渐成熟，**==栈上分配、标量替换优化技术==**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对” 了

​	在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有种特殊情况，那就是**如果经过逃逸分析（ Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术

​	此外，前面提到的基于 **Open JDK** 深度定制的 **Taobao VM**，其中创新的 **GCIH（GC invisible heap）技术**实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的



> 逃逸分析

* 将堆上的对象分配到栈，需要使用逃逸分析手段，这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
* 通过逃逸分析， **Java HotSpot 编译器**能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上
* 逃逸分析的基本行为就是分析对象动态作用域
    * 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
    * 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方



> 利用逃逸分析来优化代码

一、栈上分配
	将堆分配转化为栈分配。如果一个对象在子程序中被分配要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

> ​	**JIT** 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了
>
> **==尽量使用局部变量==** 

```java
// -Xms256m -Xmx256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails
public class JVM {
    public static void main(String[] args) {
    long start = System.currentTimeMillis();

    for (int i = 0; i < 1000000; i++) {
        alloc();
    }

    long end = System.currentTimeMillis();
    System.out.println("花费时间：" + (end - start) + "ms");

    try {
        Thread.sleep(100000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    }

    public static void alloc() {
    User user = new User();
    }

    static class User {

    }
}
```



二、同步省略

> 如果一个对象被发现只能从一个线程被访问到，那么对于这对象的操作可以不考虑同步

​	线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，**JIT** 编译器可以**==借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程==**。如果没有，那么 **JIT** 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除



三、分离对象或标量替换
	有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中

> **标量**（ Scalar）是指一个无法再分解成更小的数据的数据。**Java中的原始数据类型就是标量** 
>
> ​	相对的，那些还可以分解的数据叫做聚合量（ Aggregate），Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
>
> ​	在 **JIT** 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 **JIT** 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换



```java
public static void alloc() {
    User user = new User();
    System.out.println(user.x + user.y);
}
static class User {
    private int x;
    private int y;
}
```

* 以上代码可以替换为

```java
public static void alloc() {
    int x, y;
    System.out.println(x + y);
}
```

​	可以看到， User 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。**那么标量替换有什么好处呢？就是可以大大减少堆内存的占用**。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

标量替换为栈上分配提供了很好的基础

> -XX:+EliminateAllocations：开启标量替换（默认是开启的）

```java
// -Xms256m -Xmx256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+EliminateAllocations
public class JVM {
    public static void main(String[] args) {
    long start = System.currentTimeMillis();

    for (int i = 0; i < 1000000; i++) {
        alloc();
    }

    long end = System.currentTimeMillis();
    System.out.println("花费时间：" + (end - start) + "ms");

    try {
        Thread.sleep(100000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    }

    public static void alloc() {
    User user = new User();
    user.id = 1;
    user.name = "TFC";
    }

    static class User {
    private int id;
    private String name;
    }
}
```



#### 5.7.1 逃逸分析小结

* 注意：逃逸分析只能在 **Server** 模式下使用（默认的）

> **-Server**：启动 **Server** 模式，因为在 **Server** 模式下，才可以启用逃逸分析

​	1、关于逃逸分析的论文在1999年就已经发表了，但直到 JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。其根本原因就是==**无法保证逃逸分析的性能消耗一定能高于他的消耗**==。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析，这其实也是一个相对耗时的操作。

​	2、一个极端的例子，**就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费了** 

​	3、虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段

​	4、注意到有一些观点，认为通过逃逸分析，**JVM** 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知， **目前 Oracle HotSpot JVM** 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上



## 6、方法区

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200702113802.png)



### 6.1 栈、堆、方法区的交互关系

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200702114536.png)



### 6.2 方法区的理解

* 官方文档解释

​	**Java 虚拟机具有一个在所有 Java 虚拟机线程之间共享的方法区域**。该方法区域类似于常规语言的编译代码的存储区域，或者类似于操作系统过程中的“文本”段。它存储每个类的结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化以及接口初始化的特殊方法

​	**方法区域是在虚拟机启动时创建的**。尽管方法区**==在逻辑上是堆的一部分==**，但简单的实现可以选择不进行垃圾回收或压缩。该规范没有规定方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以缩小。**方法区域的内存不必是连续的**。

​	**==方法区是独立于 Java 堆空间的一块内存空间==**

​	**Java** 虚拟机提供对方法区域初始大小的控制，以及在方法区域大小可变的情况下，可以控制最大和最小方法区域大小，如果无法提供方法区域中的内存来满足分配请求，则 **Java** 虚拟机将抛出一个 **OutOfMemoryError** 



### 6.3 方法区的演进

* 针对的是官方虚拟机 **HotSpot** 

​	1、在 JDK7 及以前，习惯上把方法区称为**永久代**，JDK8 开始，使用**元空间**取代了永久代

​	2、而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地实现的元空间（ Metaspace）来代替

​	3、元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存** 

​	4、永久代、元空间二者并不只是名字变了，内部结构也调整了

​	5、根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常



### 6.4 方法区大小与 OOM

> 方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整



**JDK7**及以前：

通过 **-XX:PermSize** 来设置永久代初始分配空间。默认值是 **20.75M** 
**-XX:MaxPermsize** 来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器默认是 82M

**JDK8**及以后

​	1、元数据区大小可以使用参数 **-XX:MetaspaceSize** 和 **-XX:MaxMetaspaceSize** 指定替代上述原有的两个参数

​	2、默认值依赖于平台。 **windows**下，**-XX:MetaspaceSize** 是 21M，**-XX:MaxMetaspaceSize** 的值是 -1，即没有限制

​	3、与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 **OutofMemoryError:Metaspace** 

​	4、**-XX:MetaspaceSize**：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 -XX:Metaspace Size 值为 21MB。这就是**初始的高水位线**，一旦触及这个水位线，**Full GC** 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。**新的高水位线的值取决于 GC 后释放了多少元空间**。如果释放的空间不足，那么在不超过 **MaxMetaspacesize** 时，适当提高该值。如果释放空间过多，则适当降低该值

​	5、如果初始的高水位线过低，上述高水位线调整情况会发生很多次。通过垃圾回器的日志可以观察到 **Full GC** 多次调用。为了避免频繁地 **Full  GC**，建议将 **-XX:MetaspaceSize** 设置为一个相对较高的值



### 6.5 方法区的内部结构

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200702192011.png)



《深入理解Java虚拟机》书中对方法区（ Method area）存储内容描述如下：

> 它用于存储已被虛拟机加载的**==类型信息、常量、静态变量、即时编译器编译后的代码缓存==**等

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200702192521.png)



#### 6.5.1 类型信息

对每个加载的类型 (类 **Class**、接口 **Interface**、枚举 **Enum**、注解 **Annotation**)，JVM 必须在方法区中存储以下类型信息

1、这个类型的完整有效名称（全名=包名+类名）

2、这个类型直接父类的完整有效名（对于 Interface 或是 java.lang.Object，都没有父类）

3、这个类型的修饰符（ public, abstract,final 的某个子集）

4、这个类型直接接口的一个有序列表



#### 6.5.2 域信息

1、JVM 必须在方法区中保存类型的所有**域的相关信息**以及域的**声明顺序** 

2、域的相关信息包括：域名称、域类型、域修饰符（public, private, protected, static, final, volatile, transient 的某个子集）



#### 6.5.3 方法信息

JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序

1、方法名称、方法的返回类型、方法参数的数量和类型（按顺序）

2、方法的修饰符（ public, private, protected, static,fina1，synchronized, native, abstract的一个子集）

3、方法的字节码（ bytecodes）、操作数栈、局部变量表及大小（ abstract 和 native 方法除外）

4、异常表（ abstract 和 native 方法除外）
	每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引



#### 6.5.4 运行时常量池

* 运行时常量池和常量池

1、**==方法区==**内部包含了**运行时常量池** 

2、**==字节码文件==**内部包含了**常量池** 

3、要弄清楚方法区，需要理解清楚 **ClassFile**，因为加载类的信息都在方法区

4、要弄清楚方法区的运行时常量池，需要理解清楚 **ClassFile** 中的常量池



* 常量池

> ​	一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是**常量池表，常量池表包含各种字面量和对类型、域、方法的==符号引用==** 



> **==常量池==**的作用

​	一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，**通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池**，**==这个字节码包含了指向常量池的引用==**。在动态链接的时候会用到运行时常量池

常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200703102426.png)



* 运行时常量池

​	1、**运行时常量池**（ Runtime Constant Pool）是**方法区**的一部分

​	2、常量池表是 **class** 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将**在类加载后存放到方法区的运行时常量池中** 

​	3、运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池

​	4、**JVM** 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过**索引访问**的

​	5、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为**真实地址** 

​	6、运行时常量池，相对于 **class** 文件常量池的另一重要特征是：**具备动态性** 

​	7、运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富

​	8、当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则**JVM** 会抛 **OutOfMemoryError** 异常



### 6.6 方法区的演进过程

​	首先明确：只有 **Hotspot** 才有永久代，**BEA、JRockit、IBM、J9** 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟杋规范》管束，并不要求统一

**Hotspot** 中方法区的变化

|        版本        |                             变化                             |
| :----------------: | :----------------------------------------------------------: |
| **JDK 1.6** 及之前 |  有永久代（ permanent generation），静态变量存放在永久代上   |
|    **JDK 1.7**     | 有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量保存在堆中 |
| **JDK 1.8** 及以后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆上 |

JDK 1.6

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200703112525.png)

JDK 1.7

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200703112624.png)

JDK 1.8

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200703112751.png)



> 为什么要用**元空间**替换**永久代** 

1、因为永久代设置空间大小是很难确定的

* 在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误
* 而元空间和永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制

2、对永久代进行调优是很困难的



> 为什么要将 **==String Table==**  放到堆空间中

​	JDK7 中将 **StringTable** 放到了堆空间中。因为**永久代的回收效率很低**，在 **Full GC** 的时候才会触发。而 **Full GC** 是老年代的空间不足、永久代不足时才会触发。这就导致 **String Table** 回收效率不高。而我们**开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存** 



### 6.7 方法区的垃圾回收

​	一般来说这个区域的**回收效果比较难令人满意**，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 **Sun** 公司的 **Bug** 列表中，曾出现过的若干个严重的 **Bug** 就是由于低版本的 **Hotspot** 虚拟机对此区域未完全回收而导致内存泄漏

方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量**和**不再使用的类型** 



* 常量回收

​	1、方法区内常量池之中主要存放的两大类常量：**字面量和符号引用**。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 **final** 的常量值等。而**符号引用则属于编译原理方面的概念**，包括下面三类常量

* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符

​	2、**HotSpot** 虚拟机对常量池的回收策略是很明确的，**只要常量池中的常量没有被任何地方引用，就可以被回收** 

​	3、回收废弃常量与回收 Java 堆中的对象非常类似



* 类型回收（Java 的回收）

​	1、要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要**同时满足下面三个条件**：

* 该类所有的**实例**都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
* 加载该类的**类加载器**已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的
* 该类对应的 **java.lang.Class** 对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法** 

​	2、Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是 “被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收 **Hotspot** 虚拟机提供了**-Xnoclassgc** 参数进行控制，还可以使用**-verbose:class** 以及 **-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading** 查看类加载和卸载信息

​	3、在大量使用反射、动态代理、 **CGLib** 等字节码框架，动态生成 **JSP** 以及 **OSGi** 这类频繁自定义类加载器的场景中，通常都需要 **Java** 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力



## 7、小结

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200703144915.png)



# 四、对象实例化内存布局与访问定位

> 对象是如何存储于访问的？



## 1、对象创建的方式

1、使用 **new** 关键字调用构造器创建对象

2、**Class** 的 **newInstance()**，反射的方式，只能调用空参构造器，权限必须是 **public**（**JDK 8** 及以前）

3、**Constructor** 的 **newInstance(xxx)**，反射的方式，可以调用带参、不带参的构造器，权限没有要求（**JDK 8** 以后）

4、使用 **clone()**，不调用任何构造器，但当前类必须实现 **Cloneable** 接口，实现 **clone()** 方法

5、使用反序列化，从文件、网络中获取一个对象的二进制流

6、第三方库 **Objenesis** 



## 2、对象创建步骤

1、判断对象对应的类是否加载、链接、初始化

> ​	虚拟机遇到一条 **new** 指令，首先去检查这个指令的参数能否在 **Metaspace** 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲要派模式下，使用当前类加载器以 **ClassLoader** + 包名 + 类名为 Key 进行查找对应的 **.class** 文件，如果没有找到文件，则抛出 **ClassNotFoundException** 异常，如果找到，则进行类加载，并生成对应的 **Class** 类对象

2、为对象分配内存

> ​	首先计算对象占用空回大小，接着在堆中划分一块内存给新对象，如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小

* 如果内存**==空间规整==**，采用**指针碰撞法** 

> ​	如果内存是规整的，那么虚拟机将采用的是指针碰撞法（ Bump The Pointer）来为对象分配内存。
>
> ​	意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，**==分配内存就仅仅是把指针向空闲那边动一段与对象大小相等的距离==**。如果垃圾收集器选择的是 Serial、ParNew 这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带有 compact（整理）过程的收集器时，使用指针碰撞

* 如果**==空间不规整==**，虚拟机需要维护一个**空闲列表** 

> ​	如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是**空闲列表法**来为对象分配内存。
> ​	意思是虚拟机维护了一个列表，记录了哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分始对象实例，并更新列表上的内容。这种分配方式成为空闲列表（ Free List）

* 说明
    * 择哪种分配方式由 **Java** 堆是否规整决定，而 **Java** 堆是否规整又由所采用的**圾收集器是否带有压缩整理功能**决定

3、处理并发安全问题

* 采用 CAS 失败重试、区域加锁保证更新的原子性
* 每个线程预先分配一块 **TLAB**，通过 **-XX+/-UseTLAB** 参数来设定

4、初始化分配到的空间（默认初始化）

> 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用

5、设置对象的对象头

> ​	将对象的所属类（即类的数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于 JVM 实现

6、执行 **init()** 方法进行初始化

> ​	在 Java 程序的视角看来，执行 **init()**，初始化才正式开始，初始化成员变量，执行实例化代码适方法，并把堆内对象的首地址赋值给引用变量。
> ​	因此一般来说（由字节码中是否跟随有  invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来



## 3、对象的内存布局

==**对象头**== 

1、运行时元数据

> 哈希值、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳

2、类型指针

> 指向元数据 InstanceKlass，确定该数据所属类型

* 说明：如果是数组，还需要记录数组长度



**==实例数据==** 

* 说明：**==它是对象真正存储的有效信息==**，包括程序代码中定义的各种类型的字段（包括从父关继承下来的和本身拥有的字段）

规则

1、相同宽度的字段总是被分配在一起

2、父类中定义的变量会出现在子类之前

3、如果 **CompactFields** 参数为 true （默认为true），子类中较窄的变量可能插入到父类变量的空隙



**==对齐填充==** 

> 不是必须的，也没特别含义，仅仅起到占位符的作用

​	由于 **HotSpot** 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是**任何对象的大小都必须是 8 字节的整数倍**。对象头部分已经被精心设计成正好是 8 字节的倍数（1倍或者2倍），因此，**如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全** 

举例

```java
public class Customer{    int id=101;    String name;    Account acct;        {    name="匿名客户";    }    public Customer(){    acct=new Account();    }}class Account{}
```

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706101256.png)





## 4、对象访问定位

> **JVM** 是如何通过**栈帧**中的**对象引用**访问到其内部的对象实例的呢？
>  定位：通过栈上的 **reference** 访问

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706102107.png)

### 4.1 对象访问方式

> **==句柄访问==**

​	好处：**reference** 中存储稳定句柄地址，当对象被移动（垃圾收集时移动对象很遍）时只会改变句柄中实例数据指针即可， **reference** 本身不需要被修改

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706102328.png)



> 直接指针访问（**HotSpot** 使用）

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706102501.png)





# 五、直接内存

概述

1、直接内存不是 **JVM** 运行时数据区的一部分，也不是《**Java** 虚拟机规范》中定义的内存区域

2、直接内存是在 **Java** 堆外的、**直接向系统申请的内存区间** 

3、来源于 **NIO**，通过存在堆中的 **DirectByteBuffer** 操作 **Native** 内存

4、通常，**==访问直接内存的速度会优于 Java 堆，即读写性能高==**
	因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存
	**Java** 的 **NIO** 库允许 **Java** 程序使用直接内存，用于数据缓冲区

5、也可能导致 **OutOfMemoryError** 异常。由于直接内存在 **Java** 堆外，因此它的大小不会直接受限于 **-Xmx** 指定的最大堆大小，但是系统内存是有限的，**Java** 堆和直接内存的总和依然受限于操作系统能给出的最大内存

6、缺点
	分配回收成本较高，不受 **JVM** 内存回收管理

> **直接内存大小可以通过 MaxDirectMemorysize 设置，如果不指定，默认与堆的最大值 -Xmx 参数值一致** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706121330.png)





# 六、执行引擎

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706122813.png)

概述

1、执行引擎是 Java 虛拟机核心的组成部分之一

2、“虚拟机” 是一个相对于 “物理机” 的概念，这两种机器都有代码执行能力，其区别是**==物理机==的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而==虚拟机==的执行引擎则是由软件自行实现的**，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，**能够执行那些不被硬件直接支持的指令集格式** 

3、JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为**字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息**。那么，如果想要让一个 Java 程序运行起来，需要**执行引擎（ Execution Engine）将字节码指令 解释/编译 为对应平台上的本地机器指令**才可以。简单来说，**==JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者==** 



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706123623.png)



## 1、Java代码编译和执行的过程

基本过程

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706142418.png)



> **==前端编译器==**所做工作：将 J**ava 代码**翻译成 JVM 能识别的**字节码文件**（上图黄色部分）

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706142049.png)

> **及时编译**过程：将 Java 字节码文件编译成对应机器能识别的机器指令（上图绿色部分）

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706142143.png)



> 什么是**解释器（Interpreter）** 

​	解释器：当 Java 虚拟机启动时会根据预定义的规范**对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行** 

> **JIT（Just  In  Time  Compiler）** 编译器

**JIT** 编译器：就是虚拟机**将==源代码==直接编译成和本地机器平台相关的机器语言（机器指令）** 



## 2、机器码、执行、汇编语言

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706145504.png)



> 机器码

1、各种用二进制编码方式表示的指令，叫做**机器指令码**。开始，人们就用它采编写程序，这就是机器语言

2、机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且编程时易出错

3、用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，**执行速度最快** 

4、机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同



> 指令

1、由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令

2、指令就是**把机器码中特定的 0 和 1 序列，简化成对应的指令**（一般为英文简写，如mov，inc等）可读性稍好

3、由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同



> 指令集

1、不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集

2、如常见的 **x86 指令集**，对应的是 **x86 架构的平台**，**ARM 指令集**，对应的是 **ARM 架构的平台** 



> 汇编语言

1、由于指令的可读性还是太差，于是人们又发明了汇编语言

2、在汇编语言中，**用==助记符==代替机器指令的==操作码==，用==地址符号（ symbol）或标号（Label）==代替指令或==操作数的地址==** 

3、在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。由于计算机只认识指令码，所以**用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行** 



![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200706145155.png)





## 3、解释器

* 字节码

1、字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码

2、字节码主要为了实现特定软件运行和软件环境、与硬件环境无关

3、字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，**特定平台上的虚拟机器**将字节码转译为可以直接执行的指令



​	**JVM** 设计者们的初衷仅仅只是单纯地为了满足 **Java** 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现**==解释器==在运行时采用逐行解释字节码执行程序**的想法

​	解释器真正意义上所承担的角色就是一个**运行时 “翻译者”**，将字节码文件中的内容 “翻译” 为对应平台的本地机器指令执行

​	当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作



​	在 **Java** 的发展历史里，一共有两套解释执行器，即古老的字**==字节码解释器==**、现在普遍使用的**==模板解释器==** 

* **字节码解释器**在执行时通过纯软件代码模拟字节码的执行，**效率非常低下** 
* **模板解释器**将每一条字节码和一个模板函数相关联，**模板函数中直接产生这条字节码执行时的机器码**，从而很大程度上提高了解释器的性能

> 在 **Hotspot VM** 中，解释器主要由 **Interpreter 模块**和 **Code 模块**构成
> 	**Interpreter** 模块：实现了解释器的核心功能
> 	**code** 模块：用于管理 **Hotspot VM** 在运行时生成的本地机器指令



* 现状

​	由于解释器在设计和实现上非常简单，因此除了**Java** 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Per、Ruby 等。**但是在今天，基于解释器执行已经沦落为低效的代名词**，并且时常被一些 **C/C++** 程序员所调侃

​	为了解决这个问题，JVM 平台支持一种叫作**==即时编译的技术==，即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可**，这种方式可以使执行效率大幅度提升。



## 4、JIT编译器

* Java 代码执行分类

​	1、第一种是将源代码编译成字节码文件，然后在运行时通过**解释器**将字节码文件转为机器码执行

​	2、第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT, Just in time）**将方法直接编译成机器码后再执行** 



​	**Hotspot VM 采用==解释器==与==即时编译器==并存的架构**。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间



> 既然 Hotspot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？

​	首先明确当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。

​	尽管 **JRockit VM** 中程序的执行性能会非常高效，但**程序在启动时必然需要花费更长的时间来进行编译**。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。

​	在此模式下，当 **Java** 虚拟器启动时，**解释器**可以首先发挥作用，而不必等待即时编译器全编译完成后再执行，这样**可以省去许多不必要的编译时间**。随着时间的推移，即时编译器逐渐发挥作用，根据**==热点探测功能==**，将有价值的字节码编译为本地机器指令以换取更高的程序执行效率



​	Java 语言的 “编译期” 其实是一段 “不确定” 的操作过程，因为它可能是指一个**前端编译器**（其实叫“编译器的前端”更准确一些）**把 .java文件转变成 .class 文件的过程**

​	也可能是指虚拟机的**后端运行期编译器**（JIT 编译器， Just In Time Compiler）**把==字节码==转变成机器码的过程** 

​	还可能是指使用**静态提前编译器**（AOT编译器， Ahead of Time Compiler）**直接把 ==.java 文件==编译成本地机器代码的过程** 



> 热点代码探测方式

​	是否需要启动 **JIT** 编译器将字节码直接编译为对应平台的本地机器指令则**需要根据代码被调用执行的频率而定**。关于那些需要被编译为本地代码的字节码，也被称之为 “热点代码”，**JIT** 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能

​	**一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为 “热点代码”**，因此都可以通过 JIT 编译器编译为本地机器指令。**由于这种编译方式发生在==方法的执行过程中==，因此也被称之为==栈上替换==**，或简称为**OSR**（ On stack Replacement）编译

​	一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些 “热点代码” 编译为本机器指令执行。这里主要依靠**热点探测功能** 

​	**目前 Hotspot VM 所采用的热探测方式是基于==计数器==的热点探测** 

​	采用基于计数器的热点探测， **Hotspot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为==方法调用计数器==和==回边计数器==** 

> 方法调用计数器：用于统计方法的调用次数
> ​回边计数器：用于统计循环体执行的循环次数



> 方法调用计数器：用于统计方法的调用次数

​	这个计数器就用于统计方法被调用的次数，它的默认阈值在 **Client 模式下是1500次**，在 **Server 模式下是10000次**。超过这个阈值，就会触发 JIT 编译，这个阈值可以通过虚拟机参数 **-XX:CompileThreshold** 来人为设定

​	当一个方法被调用时，会先检査该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707112445.png)





> 热度衰减

​	如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。**当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器阈值就会被减少一半**，这个过程称为**==方法调用计数器热度的衰减==**，而这段时间就称为此方法统计的半衰周期

​	**进行热度衰减的动作是在虚拟机进行==垃圾收集==时顺便进行的**，可以使用虚拟机参数 **-XX:-UseCounterDecay** 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码

​	使用 **-XX:CounterhalfILifeTime** 参数设置半衰周期的时间，单位是秒



> 回边计数器

​	它的作用是统计一个方法中循环体代码执行的次数，**在字节码中遇到控制流向后跳转的指令称为 “回边”**。显然，建立回边计数器统计的目的就是为了触发 **OSR（栈上替换）** 编译



> **Hotspot VM** 设置程序执行方式

**-Xint**：**完全采用解释器模式**执行程序

**-Xcomp**：**完全采用即时编译器模式**执行程序。如果即时编译出现问题，解释器会介入执行

**-Xmixed**：**采用解释器+即时编译器的混合模式**共同执行程序（默认）



> **Hotspot VM** 中 **JIT** 分类

​	**在 Hotspot VM 中内嵌有两个 JIT 编译器，分别为 ==Client Compiler== 和 ==Server Compiler==，但大多数情况下我们简称为 C1 编译器和 C2 编译器**。开发人员可以通过如下命令显式指定 **Java** 虚拟机在运行时到底使用哪一种即时编译器，如下所示

​	**-Client**：指定 Java 虚拟机运行在 **Client 模式**下，并使用 **C1 编译器**，**C1 编译器会对字节码进行==简单可靠的优化，耗时短==。以达到更快的编译速度** 

​	**-Server**：指定 Java 虚拟机运行在 **Server 模式**下，并使用 C2编译器，**C2 进行==耗时较长==的优化，以及==激进优化==。但优化的==代码执行效率更高==** 



> **==C1（Client）==** 的优化策略

方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程

去虚拟化：对唯一的实现类进行内联

冗余消除：在运行期间把一些不会执行的代码折叠掉



> **==C2（Server）==** 的优化策略

标量替换：用标量值代替聚合对象的属性值

栈上分配：对于未逃逸的对象分配对象在栈而不是堆

同步消除：清除同步操作，通常指 synchronized



> 分层编译（ Tiered Compilation）策略

​	程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。

​	不过在 Java7 版本之后，一旦开发人员在**程序中==显式==指定命令 “- server” 时，默认将会开启分层编译策略**，由 C1编译器和 C2 编译器相互协作共同来执行编译任务



# 七、String 解析



## 1、String的基本特性

**String** 声明为 **final** 的，不可被继承

**String** 实现了 **Serializable** 接口：表示字符串是**支持序列化**的。实现了 **Comparable**接口：表示 **String** 可以**比较大小** 

**String** 在 **JDK 8 以前**内部定义了 **final char[] value** 于存储字符串数据。**JDK9 时改为 byte[]**

​	**String** 该类的当前实现将字符存储在 **char** 数组中，每个字符使用两个字节（十六位）。从许多不同的应用程序收集的数据表明，字符串是堆使用情况的主要组成部分，而且，**大多数 String 对象仅包含 Latin-1 字符。这样的字符仅需要一个字节的存储空间，因此 String 对象的内部数组中的 一半空间未使用** 

​	我们建议 **String 类的内部表示形式从 UTF-16 char 数组更改为 byte 带有==编码标记==字段的数组**。新 **String** 类将存储基于字符串内容编码为 ISO-8859-1 / Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的字符。**编码标志将指示使用哪种编码** 

> String 再也不用 char 来存储了，改成了 **byte 加上编码标记**，节约了一些空间



**String**：代表不可变的字符序列。简称：不可变性

1、当对字符串**==重新赋值==**时，需要重写指定内存区域赋值，不能使用原有的 **value** 进行赋值

2、当对现有的字符串进行**==连接操作==**时，也需要重新指定内存区域赋值，不能使用原有的 **value** 进行赋值

3、当调用 **String** 的 **replace()** 方法**==修改指定字符或字符串==**时，也需要重新指定内存区域赋值，不能使用原有的 **value** 进行赋值

​	通过字面量的方式（区别于new）给一个字符串赋值，**此时的字符串值声明在==字符串常量池==中**，**==字符串常量池中是不会存储相同内容的字符串的==** 

​	1、**String** 的 **String Pool** 是一个固定大小的 **Hashtable**，**默认值大小长度是 1009（以前）**，如果放进 **String Pool** 的 **String**非常多，就会造成 **Hash 冲突严重**，从而导致链表会很长，而链表长了后直接会造成的影响就是当**调用 String.intern 时性能会大幅下降** 

​	2、使用 **-XX:StringTableSize** 可设置 **StringTable** 的长度

​	3、**在 JDK6 中 Stringtable 是固定的，就是 1009 的长度**，所以如果常量池中的字符串过多就会导致效率下降很快

​	4、**在 JDK8 中， Stringtable 的长度默认值是 60013，1009 是可设置的最小值** 



## 2、String 的内存分配

​	在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 **String**。这些类型**为了使它们在运行过程中速度更快、更节省内存，都提供了一种==常量池==的概念** 

​	**常量池就类似一个Java系统级别提供的缓存**。8 种基本数据类型的常量池都是系统协调的

**String** 类型的常量池比较特殊，它的主要使用方法有两种

​	1、直接使用双引号声明出来的 **String** 对象会直接存储在常量池中，比如：String info = "atguigu";

​	2、如果不是用双引号声明的 **String** 对象，可以使用 **String** 提供的 **intern() 方法** 



Java 6 及以前，字符串常量池存放在永久代

Java 7 中，**字符串常量池的位置调整到Java堆中** 

​	1、所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了

​	2、字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们**重新考虑在 Java7 中使用 string.intern()** 

​	3、Java 8 有了元空间，字符串常量还是在堆中



## 3、字符串的拼接

1、**常量与常量**的拼接结果在常量池，原理是编译期优化

```java
@Test
public void test01() {
    String s1 = "a" + "b" + "c";  
    String s2 = "abc";

    System.out.println(s1 == s2);     // true
    System.out.println(s1.equals(s2));	  // true
}
```

反编译的结果

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707163508.png)



2、常量池中不会存在相同内容的常量

3、**只要其中有一个是变量，结果就在堆中**，变量拼接的原理是 **StringBuilder** 

4、如果拼接的结果调用 **intern()** 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

```java
@Test
public void test02() {
    String s1 = "JavaEE";
    String s2 = "hadoop";

    String s3 = "JavaEEhadoop";
    String s4 = "JavaEE" + "hadoop";
    
    /**
     * 如果拼按符号的前后出现了变量，则相当于在堆空间中 new string()
     * 具体的内容为拼接的结果
     */
    String s5 = s1 + "hadoop";
    String s6 = "JavaEE" + s2;
    String s7 = s1 + s2;

    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // fasle
    System.out.println(s3 == s6); // false
    System.out.println(s3 == s7); // false
    System.out.println(s5 == s6); // false
    System.out.println(s5 == s7); // false
    System.out.println(s6 == s7); // fasle

    /**
     * intern()：判断字符审常量池中是否存在 javaEEhadoop值
     * 如果存在，则返回常量池中 javaEEhadoop的地址；
     * 如果字符申常量池中不存在 javaEEhadoop,
     * 则在常量池中加载一份 JavaEEhadoop，并返回其对象的地址
     */
    String s8 = s6.intern();
    System.out.println(s3 == s8); // true
}
```

```java
@Test
public void test03() {
    String s1 = "a";
    String s2 = "b";
    String s3 = "ab";

    /**
     * s1 + s2 执行细节
     * StringBuilder s=new StringBuilder();
     * s.append("a");
     * s.append("b");
     * s.toString();
     * 补充：
     *      在jdk5.0之后使用的是 StringBuilder
     *      在jdk5.0之前使用的是 stringBuffer
     */
    String s4 = s1 + s2;
    System.out.println(s3 == s4);
}
```

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707170543.png)



```java
@Test
public void test04(){
    final String s1 = "a";
    final String s2 = "b";
    String s3 = "ab";

    String s4 = s1 + s2;  // 常量引用
    System.out.println(s3 == s4);  // true
}
```



> 使用 + 号拼接与使用 StringBuilder 拼接效率比较

```java
@Test
public void test05() {

    String a = "a";

    long start = System.currentTimeMillis();
    for (int i = 0; i < 100000; i++) {
    a += "a";
    }
    long end = System.currentTimeMillis();
    System.out.println(end - start);      // 5984ms

    StringBuilder builder = new StringBuilder();
    start = System.currentTimeMillis();
    for (int i = 0; i < 100000; i++) {
    builder.append("a");
    }
    end = System.currentTimeMillis();
    System.out.println(end - start);       // 2ms
}
```

* 原因
    * 使用 + 号拼接每次都会创建一个 StringBuilder 对象

> 对 StringBuilder 方式还可以进行优化

​	**StringBuilder**  底层使用字符数组来存储数据，数组长度不够时就需要扩容，扩容所花费时间较长，初始字符数组长度较小，为避免多次扩容，可以为 **StringBuilder**  底层使用的字符数组指定一个初始长度，避免进行多次扩容



## 4、intern() 的使用

> 方法解释

当一个字符串对象使用此方法是，会先去字符串常量池中查找有没有与此**字符串的值**相同的，如果有则返回常量池中改字符串的引用，如果没有，则在字符串常量池中新创建一个，然后返回引用



## 5、new String("a") 详解

> **==new String("ab")==**  会创建几个对象？

两个，一个是 new 关键字在堆空间创建的一个对象，一个是字符串常量池中的对象

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707191435.png)



> **==new String("a") + new String("b")==** 会创建几个对象？

对象1：new StringBuilder

对象2：new String("a")

对象3：常量池中的 "a"

对象4：new String("b")

对象5：常量池中的 "b"

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707192305.png)

> 深入剖析 **StringBuilder 的 toString 方法** 

对象6：**new String("ab")** 

* 注意：**toString() 的调用，在常量池中没有生成 "ab"** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707192859.png)





> 经典面试难题：**intern()** 的使用

```java
@Test
public void test06() {
    String s = new String("1"); //在堆中生成一个 new String("1") 的同时，也在字符串常量池中创建了一个对象
    s.intern();

    String s2 = "1"; // 此时返回的是字符串常量池中的对象
    System.out.println(s == s2);  // 结果1

    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    System.out.println(s3 == s4); // 结果2
}
```

* JDK 6 中的结果
    * 都是 **false** 

> 结果 1 很好解释，详细剖析结果 2

1、由之前的分析可得，**new String("1") + new String("1")**：这句代码执行完之后，字符串常量池中没有 "11"，只是在堆空间中创建了一个 **new String("11")** 对象

2、**s3.intern()**：JDK 6当中此代码是在字符串常量池中生成了一个新的对象 "11"，也就有了新的地址

3、**String s4 = "11"**：此代码获得字符串常量池中的对象引用，与 s3 不是同一对象，故为 **false** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707200131.png)

* JDK 7/8
    * 结果 1 为 false，结果 2 为 true

> 结果 1 很好解释，详细剖析结果 2

​	1、由之前的分析可得，new String("1") + new String("1")：这句代码执行完之后，字符串常量池中没有 "11"，只是在堆空间中创建了一个 new String("11") 对象

​	2、s3.intern()：JDK 7/8 当中此代码没有在字符串常量池中生成新的对象，而是在常量池中创建了一个直接指向了堆空间的 new String("11") 地址

​	3、String s4 = "11"：此代码获得字符串常量池中的对象引用，在 JDK 7/8 中也就是堆空间的引用，与 s3 是同一个对象，故为 **true** 

![](C:/Users/tfc/Desktop/笔记/MarkDown/JVM/images/TIM截图20200707200215.png)



## 6、Intern() 总结

**JDK 1.6** 中，将一个字符串对象尝试放入串池

1、如果串池中有，则并不会放入。返回已有的串池中的对象的地址

2、如果没有，会**将此对象==复制==一份，放入串池**，并返回串池中的对象地址



JDK 1.7 起，将一个字符串对象尝试放入串池

1、如果串池中有，则并不会放入。返回已有的串池中的对象的地址

2、如果没有，则会**将对象的引用==地址==复制一份，放入串池**，并返回串池中的引用地址